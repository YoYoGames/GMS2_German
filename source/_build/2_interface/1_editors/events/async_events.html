<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Die asynchronen Ereignisse </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Objekt-Editor Asynchrone Ereignisse"> Ein <b>asynchrones Ereignis</b> wird ausgelöst, wenn <i><span class="notranslate">GameMaker Studio 2</span></i> einen &quot;Rückruf&quot; von einer externen Quelle erhält, die vom Web oder vom Gerät, auf dem das Spiel ausgeführt wird, ausgeführt wird. Im Grunde sagen Sie <i><span class="notranslate">GameMaker</span> Studio 2</i>, dass Sie etwas machen sollen, wie zum Beispiel das Laden eines Bildes, und es wird anfangen, dies zu tun, aber weiter machen, was immer es sonst tun muss, während es funktioniert. Wenn die Anfrage abgeschlossen ist, wird ein Rückruf an <i><span class="notranslate">GameMaker Studio 2</span></i> gesendet und alle <b>asynchronen Ereignisse,</b> die für diese Art von Rückruf definiert wurden, werden ausgelöst. Bitte beachten Sie, dass die asynchronen Ereignisse für <i>alle</i> Instanzen ausgelöst werden, die sie haben, ähnlich wie bei den Schlüsselereignissen <tt>http_get</tt> Rufen Sie in einer Instanz auf, haben Sie jedoch das asynchrone HTTP-Ereignis in einem anderen, um mit dem Rückruf umzugehen. <br></p><div class="note"> <b>HINWEIS</b>: Sie sollten sich darüber im Klaren sein, dass aufgrund von XSS-Schutz in Browsern Anfragen an und Versuche, Ressourcen aus verschiedenen Domänen zu laden, blockiert werden und bei Verwendung der folgenden Ereignisse möglicherweise leere Ergebnisse angezeigt werden </div><p><br> Für die asynchrone Ereigniskategorie sind verschiedene Ereignistypen definiert, die in den folgenden Abschnitten erläutert werden: </p><div class="note"> <b>HINWEIS:</b> Die Variable <tt>async_load</tt> Was in den folgenden Abschnitten erwähnt wird, ist <b>nur in diesen Ereignissen gültig</b>, da die <tt>ds_map</tt> Das heißt, Punkte werden zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht, wobei diese Variable zu allen anderen Zeiten auf den Wert -1 zurückgesetzt wird. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Audiowiedergabe</label> <input id="thirteen" type="checkbox"><div class="index_list"> Dieses Ereignis kann nur durch die <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">Wiedergabefunktionen</a> der <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">Audio-Warteschlange</a> ausgelöst werden und gibt a zurück <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die verschiedene Schlüssel / Wert-Paare enthält, die sich auf die Audio-Warteschlange beziehen, die das Ereignis ausgelöst hat. Das Ereignis wird ausgelöst, wenn Sie eine Audiowarteschlange zur Wiedergabe ausgewählt haben und ein Puffer in dieser Audiowarteschlange wiedergegeben wird. <br><br> Die folgenden Schlüssel sind in der ds_map verfügbar: <br><br><ul><li> &quot; <b>queue_id</b> &quot; - der Warteschlangenindex für die Warteschlange, die die Wiedergabe beendet hat, wie von der Funktion zurückgegeben <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot; - die Puffer-ID für den Puffer, von dem nicht mehr gespielt wird </li><li> &quot; <b>queue_shutdown</b> &quot; - wird während der normalen Wiedergabe auf 0 gesetzt und 1, wenn das Ereignis empfangen wird <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> genannt worden. Wenn dies auf 1 gesetzt ist, möchten Sie keine weiteren Daten in die Warteschlange stellen. </li></ul> Da eine Audiowarteschlange aus mehreren Puffern erstellt werden kann, kann dieses Ereignis für eine Warteschlange mehrfach ausgelöst werden, wenn das Ende jedes Abschnitts von gepuffertem Audio erreicht wird, daher der Schlüssel &quot;buffer_id&quot;. <br><br><div class="note"> <b>HINWEIS:</b> Die Variable <tt>async_load</tt> ist nur in asynchronen Ereignissen gültig, wie z <tt>ds_map</tt> Das heißt, Punkte werden zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht, wobei diese Variable auf den Wert -1 zurückgesetzt wird. Alle weiteren Datenstrukturen, die aus dem Ereignis erzeugt werden, <b>müssen jedoch mit den entsprechenden Funktionen bereinigt werden</b>. </div><br> Im folgenden Anwendungsbeispiel erstellen wir eine Audio-Queue mit 10 gepufferten Audio-Sounds und spielen die Queue ab: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Jeder Spielschritt, bei dem die Aufnahme erkannt wird, löst ein asynchrones Audioaufnahme-Ereignis aus, bei dem Sie mit der aufgezeichneten Eingabe etwa wie folgt umgehen können: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Hier überprüfen wir die Warteschlangen-ID und wenn es die gewünschte ist, überprüfen wir die Puffer-ID, um zu sehen, welcher Puffer abgespielt wurde. Wir setzen dann eine lokale Variable auf diesen Indexwert, um sie später zu überprüfen, und setzen den Puffer für dieses Geräusch auf den Anfang zurück. Sobald unsere lokale Variable 9 erreicht und anzeigt, dass die Warteschlange beendet ist, hören wir mit dem Abspielen des Sounds auf und geben die Warteschlange frei. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Audio Aufnahme</label> <input id="twelve"
type="checkbox"><div class="index_list"> Dieses Ereignis kann nur von der. Ausgelöst werden <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> Funktion und wird a zurückgeben <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die abhängig vom Rückruf der Funktion, die das Ereignis ausgelöst hat, verschiedene Schlüssel / Wert-Paare enthält. <br><br> Die folgenden Schlüssel sind in der ds_map verfügbar: <br><br><ul><li> &quot; <b>buffer_id</b> &quot; - die ID des temporären Puffers, mit dem Sie die Audiodaten abrufen können </li><li> &quot; <b>channel_index</b> &quot; - der Aufzeichnungskanalindex, der von der aufrufenden Funktion zurückgegeben wird, von der diese Daten stammen </li><li> &quot; <b>data_len</b> &quot; - die Länge der Daten (in Bytes), die Sie erhalten haben </li></ul><div class="note"> <b>HINWEIS:</b> Wie am Anfang dieser Seite erwähnt, die Variable <tt>async_load</tt> ist nur in asynchronen Ereignissen gültig, wie z <tt>ds_map</tt> Das heißt, Punkte werden zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht. Beachten Sie jedoch, dass der temporäre Puffer, in dem alle Audiodaten mit der Zuordnung gespeichert sind, auch am Ende des Ereignisses entfernt wird, sodass Sie ihn in einen benutzerdefinierten Puffer kopieren sollten, wenn Sie ihn für die spätere Verwendung beibehalten möchten. </div><br> Im folgenden Anwendungsbeispiel werden wir einen benutzerdefinierten Puffer erstellen, um unsere aufgezeichneten Audiodaten zu speichern und unser Spiel so einzustellen, dass es von der Eingangsquelle 0 aufnimmt: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Jeder Spielschritt, bei dem die Aufnahme erkannt wird, löst ein asynchrones Audioaufnahme-Ereignis aus, bei dem Sie mit der aufgezeichneten Eingabe etwa wie folgt umgehen können: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Hier überprüfen wir einfach den Schlüssel &quot;channel_index&quot;, um sicherzustellen, dass er mit dem Wert übereinstimmt, der zu Beginn der Aufzeichnung zurückgegeben wurde, und kopieren den Inhalt des temporären Puffers, der für dieses Ereignis erstellt wurde, in unseren benutzerdefinierten Puffer. Danach können Sie tun, was Sie wollen, mit dem benutzerdefinierten Puffer - Sie könnten es mit den dedizierten Puffer Audio-Funktionen spielen, könnten Sie es verarbeiten und senden Sie es über das Netzwerk, Sie könnten es auf der Festplatte speichern... Sobald Sie Ihre Audio aufgezeichnet haben In einem Puffer können Sie grundsätzlich alles machen, was Sie wollen. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Wolke</label> <input id="five" type="checkbox"><div class="index_list"> Das Cloud-Ereignis ist ein Ereignis, das durch den Rückruf eines der folgenden Ereignisse ausgelöst wird <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> Funktionen</a>, wie <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. Es erzeugt tatsächlich ein <tt>ds_map</tt> Dies ist exklusiv für dieses Ereignis und wird in der speziellen Variablen <b>async_load</b> gespeichert (siehe die einzelnen Funktionen für Codebeispiele, die die Verwendung dieses Ereignisses im Detail erläutern). Diese ds_map hat folgende Struktur: <br><br><ul><li> <b>&quot;status&quot;:</b> Enthält den Statuscode, wobei ein negativer Wert einen Fehler angibt, dessen Beschreibung im &quot;errorString&quot; enthalten sein wird. Ein Wert von 0 (oder ein positiver Wert) zeigt einen Erfolg an (genaue Werte siehe unten), und der &quot;resultString&quot; enthält die zurückgegebenen Daten oder eine Erfolgsmeldung. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die ID, die von der aufgerufenen Funktion zurückgegeben wurde. Wenn Sie eine Reihe von abfeuern <tt>cloud_</tt> Anfragen, dann müssen Sie wissen, auf welche Sie die Antwort bekommen, und so würden Sie diesen Wert verwenden, um mit dem Wert zu vergleichen, den Sie speicherten, als Sie ursprünglich die Anfrage schickten, um die richtige zu finden. </li><li style="list-style: none"><br></li><li> <b>&quot;description&quot;:</b> Die Beschreibung der zuletzt hochgeladenen Datei. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;: Enthält</b> eine Zeichenfolge, bei der es sich um das aus der Cloud zurückgegebene Datenblob handelt. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;:</b> gibt eine Error String für einen Fehler zurück. </li></ul> Die genaue Bedeutung des zurückgegebenen Karteneintrags &quot;Status&quot; wird in der folgenden Tabelle erläutert: <div class="compat"><table><tr><th> Statuswert </th><th> errorString / resultString </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;Nicht bei &lt;SERVICE&gt; angemeldet&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = wiederhergestellte Daten </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;AlreadySynchronized&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Beschreibung des Fehlers </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Dialog</label> <input id="three" type=
"checkbox"><div class="index_list"> Wie die obigen Ereignisse wird das <b>Dialogues-</b> Ereignis nur ausgelöst, wenn es von einer der speziellen asynchronen Benutzerfunktionen, wie z <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (Bitte beachten Sie diese Funktion für ein erweitertes Codebeispiel, wie dieses Ereignis verwendet wird). Diese Ereignisse sind diejenigen, die nach einer Art von Benutzereingabe fragen, die ein Name, Login-Details, eine Nummer oder eine Farbe usw. sein können. Da die meisten Geräte nicht gerne in einer Schleife auf eine Antwort warten, müssen sie es tun asynchron sein und <i><span class="notranslate">GameMaker Studio 2</span></i> wird weiterhin im Hintergrund laufen, während diese Funktionen einen Dialog geöffnet haben und bis sie die erforderliche Benutzereingabe erhalten, die dieses Ereignis auslöst. <br><br> Wiederum, a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> wird mit der ID zurückgegeben, die in der speziellen Variablen <b>async_load gespeichert ist</b>. Die in dieser Map enthaltenen Werte hängen von der verwendeten Funktion ab. Weitere Informationen finden Sie in den einzelnen Einträgen für jede Funktion in diesem Handbuch. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> Das HTTP-Ereignis ist ein Ereignis, das durch den Rückruf von einem der folgenden Ereignisse ausgelöst wird <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> Funktionen</a>, wie <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. Es erzeugt tatsächlich ein <tt>ds_map</tt> (manchmal auch als &quot;Wörterbuch&quot; bezeichnet), das für dieses Ereignis exklusiv ist und in der speziellen Variable gespeichert ist <tt>async_load</tt> (Bitte beachten Sie die einzelnen Funktionen für Codebeispiele, die die Verwendung dieses Ereignisses näher erläutern). Dies <tt>ds_map</tt> hat die folgende Struktur: <br><br><ul><li> <b>&quot;id&quot;:</b> Die ID, die vom Befehl zurückgegeben wurde. Wenn Sie eine Reihe von abfeuern <tt>http_</tt> Anfragen, dann müssen Sie wissen, auf welche Sie die Antwort bekommen, und so würden Sie diesen Wert verwenden, um mit dem Wert zu vergleichen, den Sie speicherten, als Sie ursprünglich die Anfrage schickten, um die richtige zu finden. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Gibt einen Wert von weniger als 0 für einen Fehler zurück, 0 für Erfolg und 1 wenn Inhalt heruntergeladen wird. </li><li style="list-style: none"><br></li><li> <b>&quot;Ergebnis&quot;:</b> Die empfangenen Daten (nur String) oder der Pfad zur heruntergeladenen Datei, falls Sie sie verwendet haben <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;:</b> Die vollständige URL, die Sie angefordert haben. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> Der rohe http-Statuscode (falls verfügbar). Dadurch wird der Standard-Webstatuscode für die meisten Browser zurückgegeben, z. B.: 304 für &quot;Nicht geändert&quot; oder 204 für &quot;Kein Inhalt&quot; usw. </li></ul> Das ist, wenn du das benutzt <tt>http_post_string()</tt> Funktion, aber jeder der <tt>http_</tt> Funktionen können eine etwas andere Karte zurückgeben, bitte lesen Sie die manuelle Eingabe für jede Funktion, um die genauen Daten herauszufinden, die dafür zurückgegeben werden. <br><br><div class="note"> <b>HINWEIS:</b> Wie <tt>async_load</tt> erstellt ein <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> Diese Funktionen sind besonders nützlich, wenn sie mit der <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> und <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> Funktionen. </div><br><br> Wenn Sie Dateien zum Herunterladen angefordert haben, können auch von dieser Karte zusätzliche Daten bereitgestellt werden. In diesem Fall hat der &quot;status&quot; den Wert 1 und die ds_map enthält diese zusätzlichen Schlüssel: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> Dies ist die Größe der Datei, die der Webserver <b>erwartungsgemäß</b> erhalten sollte (kann -1 sein, wenn der Server diese Daten nicht <b>zurückgibt</b> ). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> Die Größe der Daten, die bereits heruntergeladen wurden. </li></ul> Beachten Sie, dass das Ereignis <i>nicht</i> für jedes empfangene Datenpaket ausgelöst wird, sondern während des Downloads in der Hauptspielschleife jederzeit aktualisiert wird. Beachten Sie außerdem, dass diese Funktionalität derzeit nur für normale <i>Windows-</i> Zielplattformen verfügbar ist. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Dieses Ereignis kann nur ausgelöst werden, wenn Sie <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">In-App-Käufe</a> für Ihr Spiel aktiviert haben. Wenn Sie diese Funktionalität hinzugefügt haben, wird das Ereignis unter folgenden Umständen ausgelöst: <br><br><ul><li> Der Geschäftszustand ändert sich. </li><li> Ein Produkt (oder Produkte) wurde aktiviert. </li><li> Das Produkt und die Einkäufe wurden wiederhergestellt. </li><li> Ein Produkt wurde gekauft. </li><li> Ein Produkt wurde verbraucht. </li></ul> Das Ereignis wird immer ein besonderes erstellen <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> mit einer Index-ID, die in der eingebauten Variable gespeichert ist <tt><b>iap_data</b></tt>. Diese Karte enthält <i>immer</i> den Schlüssel &quot; <b>type</b> &quot;, der einen der folgenden konstanten Werte enthält: <div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Dies wird ausgelöst, wenn eine Änderung im Zielplattformspeicher erkannt wird. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Dieses Ereignis wird ausgelöst, wenn ein Produkt aktiviert wird und enthält zusätzliche Informationen zum Produkt. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Dieses Ereignis wird nur ausgelöst, wenn Sie die Option verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> Funktion. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Wenn ein Kauf abgeschlossen wurde, wird dieses Ereignis ausgelöst. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Wenn Sie die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> Es löst dieses Ereignis aus. </td></tr></table></div><p><br><br> Jeder dieser möglichen &quot;Ereignistypen&quot; fügt dem Schlüssel zusätzliche Schlüssel hinzu <tt>iap_data</tt> ds_map, die dann analysiert werden kann, um die Kauf- oder Produktinformationen zu erhalten. Der genaue Inhalt der <tt>iap_data</tt> Karte sind für jedes Ereignis &quot;Typ&quot; unten aufgeführt. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Wenn Sie Ihre Einkäufe aktivieren, versucht Ihr Spiel, den Zielspeicher zu kontaktieren und dieses Ereignis auszulösen. Das <tt>iap_data</tt> map wird dann einen Zusatzschlüssel &quot; <b>status&quot; haben</b>, der eine der folgenden Konstanten als Wert hat: <br><br><div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> Der Laden wurde kontaktiert und die Verbindung ist gut. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Es ist ein Verbindungsfehler aufgetreten oder aus irgendeinem Grund ist der Speicher nicht verfügbar. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Alle aktivierten Käufe werden dieses Ereignis &quot;type&quot; auslösen, aber nur einmal pro Kauf. Wenn Sie also zehn Produkte aktiviert haben, sollten Sie erwarten, dass dieses Ereignis zehn Mal ausgelöst wird. Wenn Sie diese Veranstaltung erhalten haben, <tt>iap_data</tt> ds_map enthält den zusätzlichen Schlüssel &quot; <b>index</b> &quot;, der die eindeutige <b>Produkt-ID-Zeichenfolge</b> für das Produkt enthält, das aktiviert wird. Sie können dann die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> zusammen mit dieser Produkt ID, um weitere Informationen zu erhalten. <br><br><div class="note"> <b>HINWEIS:</b> Google Play ( <span class="notranslate">Android</span> ) kann nur Details zu Produkten 20 gleichzeitig anfordern, was zu recht langen Ladezeiten für Anwendungen mit einer erheblichen Anzahl von Produkten führen kann. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Wenn Sie die Funktion aufrufen <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> Es wird dieses Ereignis ausgelöst, indem ein &quot; <b>result</b> &quot; - Schlüssel hinzugefügt wird <tt>iap_data</tt> ds_map. Diese Taste wird entweder gedrückt halten <tt>true</tt> oder <tt>false</tt> um anzuzeigen, ob die Kaufdaten erfolgreich aus dem Zielspeicher wiederhergestellt wurden. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> Wenn Sie einen Kauf über die Funktion anfordern <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> Dieser Ereignistyp wird ausgelöst. Das <tt>iap_data</tt> ds_map hat den zusätzlichen Schlüssel &quot; <b>index</b> &quot;, der den eindeutigen <b>Kauf-ID-</b> Wert für das gekaufte Produkt enthält. Sie können dann die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> zusammen mit dieser Kauf-ID, um weitere Informationen zu erhalten. <br><br><div class="note"> <b>HINWEIS:</b> Wenn das gekaufte Produkt Verbrauchsmaterial ist, <b>muss es mit verwendet</b> werden <tt>iap_consume</tt> bevor ein weiterer Kauf getätigt werden kann. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Bei Verwendung der Funktion <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> Dieser Ereignistyp wird ausgelöst. Das <tt>iap_data</tt> ds_map hat den zusätzlichen Schlüssel &quot; <b>product</b> &quot;, der die eindeutige <b>Produkt-ID-</b> Zeichenfolge für das konsumierte Produkt enthält. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Bild geladen</label> <input id=
"one" type="checkbox"><div class="index_list"> Dieses Ereignis wird ausgelöst, wenn Sie ein Bild in <i><span class="notranslate">GameMaker Studio 2</span></i> laden, sofern Sie eine gültige URL oder einen Pfad mit der entsprechenden Ladedateifunktion verwendet haben. Angenommen, Sie möchten ein Sprite-Bild laden und nur das aktuelle Sprite für die Instanz in das neue Sprite ändern, nachdem es geladen wurde. Nun, Sie würden so etwas in einem create-Event oder einem Alarmereignis haben (zum Beispiel): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Dies wird jetzt beginnen, das Bild in das Gerät oder den Browser zu laden, aber es wird <i><span class="notranslate">GameMaker Studio 2</span></i> <i>nicht</i> blockieren, während es darauf wartet, dass die Datei geladen wird. Stattdessen läuft <i><span class="notranslate">GameMaker</span> Studio 2</i> normal weiter, bis das Bild geladen wird und der Aufruf das Ereignis <b>Image Loaded</b> auslöst, wobei a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> wird in der speziellen Variablen <b>async_load</b> erstellt und gespeichert. Die Karte enthält folgende Informationen: </p><ul><li> <b>&quot;Dateiname&quot;:</b> Der vollständige Pfad zu der von Ihnen angeforderten Datei. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die ID der Ressource, die Sie geladen haben. Dies entspricht der Variablen, der Sie die Ressource zugewiesen haben. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Gibt einen Wert von weniger als 0 für einen Fehler zurück. </li></ul><p> Sie würden dann das neu geladene Bild in diesem Fall einem Hintergrund zuordnen. Das obige gilt auch für Sprites und Sounds, wobei für jede dieser Ressourcen eine ds_map wie oben gezeigt generiert wird und das folgende Codebeispiel zeigt, wie die zurückgegebenen Informationen in diesem Ereignis verwendet werden: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> Der obige Code überprüft zuerst die ID der erstellten ds_map und überprüft dann den Status des Callbacks. Wenn der Wert größer oder gleich 0 ist (Signalisierungserfolg), wird das Ergebnis des Rückrufs verwendet, um den Hintergrundindex auf das neu geladene Bild zu setzen. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">Vernetzung</label> <input id="six" type=
"checkbox"><div class="index_list"> Das Netzwerkereignis wird durch eingehenden Netzwerkverkehr ausgelöst und ist mit den <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">Netzwerkfunktionen</a> verknüpft. Dieses Ereignis generiert eine spezielle <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a>, die für dieses Ereignis exklusiv ist und in der speziellen Variablen <b>async_load</b> gespeichert ist. Dies <tt>ds_map</tt> enthält je nach Art des Netzwerkereignisses, das es generiert hat, unterschiedliche Informationen. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Gemeinsame Netzwerkereignisse</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Die folgenden Tasten sind allen empfangenen Netzwerkfunktionen gemeinsam und werden immer in der <tt>async_load</tt> Karte: <br><br><ul><li> <b>&quot;type&quot;:</b> Dies wird eine der unten aufgeführten Konstanten als Rückgabewert haben und den Netzwerkereignistyp bezeichnen. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die Socket-ID (eine reelle Zahl, wie sie von der Funktion <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> oder <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket zurückgegeben</a> wird), die das Ereignis empfängt. In den meisten Fällen ist die zurückgegebene Socket-ID die ID von TCP oder UDP-Socket, die das Ereignis ausgelöst hat. Wenn das Ereignis jedoch auf einem <i>Server</i> ausgelöst wird und es sich um ein Datenereignis handelt (siehe unten), ist die Socket-ID diejenige des <i>Clients</i>, der das Ereignis gesendet hat Daten. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> Die IP-Adresse des Sockets (als String). </li><li style="list-style: none"><br></li><li> <b>&quot;port&quot;:</b> Der der IP-Adresse zugeordnete Port (nützlich bei der Arbeit mit UDP). </li></ul> Die möglichen Rückgabewerte für den Schlüssel &quot;type&quot; können eine der folgenden drei Konstanten sein: <div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> Das Ereignis wurde durch eine Verbindung ausgelöst. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> Das Ereignis wurde durch eine Trennung ausgelöst. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> Das Ereignis wurde durch eingehende Daten ausgelöst. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> Das Ereignis wurde durch eine Verbindung ausgelöst, die als nicht blockierend konfiguriert wurde (Sie können die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> dafür). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Verbinden / Trennen</label> <input id="twentyone" type="checkbox"><div class="index_list"> Wenn Sie ein Ereignis vom Typ haben <tt>network_type_connect</tt>, <tt>network_type_non_blocking_connect</tt> oder <tt>network_type_disconnect</tt>, das <tt>async_load</tt> Karte wird die folgenden zusätzlichen Schlüssel haben: <br><br><ul><li> <b>&quot;socket&quot;:</b> Dieser Schlüssel enthält die Verbindungs- / Trennungs-Socket-ID. </li><li style="list-style: none"><br></li><li> <b>&quot;erfolgreich&quot;:</b> Dieser Schlüssel ist entweder 0 oder 1, wobei 0 bedeutet, dass die Verbindung abgelaufen ist und 1 bedeutet, dass es erfolgreich war und der Socket betriebsbereit ist. </li></ul> Es ist erwähnenswert, dass das Netzwerkereignis in <i>Clients</i> nicht ausgelöst wird, wenn der <i>Server die Verbindung</i> trennt, und dass beide nicht <tt>network_type_*</tt> Ereignisse werden in Clients ausgelöst, wenn der Server, mit dem sie verbunden sind, die Verbindung trennt, selbst wenn die Verbindung TCP-basiert ist. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Daten empfangen</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Wenn du eine hast <tt>network_type_data</tt> Geben Sie ein Ereignis ein, das angibt, dass Ihr Netzwerk Daten empfangen hat. Die erstellte Karte enthält die folgenden Schlüssel: <br><br><ul><li> <b>&quot;buffer&quot;:</b> Dies ist die eindeutige &quot;buffer id&quot;, die vom Event generiert wird. Ein Puffer vom &quot;Grow&quot; -Typ, Byte, der auf 1 ausgerichtet ist, wird erzeugt, um die ID aufzubewahren, sollte in einer Variablen gespeichert sein und für alle weiteren Funktionsaufrufe an den Puffer <i><b>in diesem Ereignis verwendet werden</b></i>. Genau wie die <tt>async_load</tt> map wird der erstellte Puffer am Ende dieses Ereignisses automatisch aus dem Speicher entfernt. Weitere Informationen zu Puffern finden Sie unter <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Referenz - Puffer</a> </li><li style="list-style: none"><br></li><li> <b>&quot;Größe&quot;:</b> Dies ist die Größe (in Bytes) der Pufferdaten, die empfangen werden. </li></ul><div class="note"> <b>Hinweis:</b> der Puffer, der erstellt wird, ist <b>nur in diesen Ereignissen gültig</b> und wird freigegeben, wenn das Ereignis beendet ist. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Push-Benachrichtigung</label> <input id="ten" type=
"checkbox"><div class="index_list"> Das Push-Benachrichtigungsereignis ist ein Ereignis, das durch den Rückruf von <b>Push-Benachrichtigungen</b> auf dem Betriebssystem des Geräts ausgelöst wird, entweder von einer lokalen Quelle, die die Funktion verwendet <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a> oder von einer entfernten Quelle (z. B. Ihrem Server). Es erzeugt ein <tt>ds_map</tt> Das ist exklusiv für dieses Ereignis und wird in der speziellen Variablen <b>async_load</b> gespeichert (siehe die einzelnen Funktionen, die asynchrone Ereignisse auslösen, für Codebeispiele, die die Verwendung dieses Ereignisses näher erläutern). Dies <tt>ds_map</tt> hat folgende Schlüssel: <br><br><ul><li> <b>&quot;type&quot;: Der</b> Wert kann &quot;lokal&quot; für eine lokale Benachrichtigung des Geräts, &quot;remote&quot; für eine Remote-Benachrichtigung oder &quot;register&quot; für die Registrierung von Remote-Benachrichtigungen sein. </li><li> <b>&quot;status&quot;:</b> Wert wird &quot;1&quot; für Erfolg oder &quot;0&quot; für einen Fehler sein. </li></ul> Abhängig vom zurückgegebenen &quot;type&quot; und dem &quot;status&quot; -Wert kann es weitere Schlüsseleingaben geben. Für &quot;Status&quot;, wenn ein Fehler zurückgegeben wurde (&quot;0&quot;), dann haben Sie auch den folgenden Schlüssel: <br><br><ul><li> <b>&quot;error&quot;:</b> Enthält Details des empfangenen Fehlers. </li></ul> Wenn der &quot;Status&quot; -Wert 1 ist (dh: keine Fehler), dann wird die <tt>ds_map</tt> enthält die folgenden zusätzlichen Werte, abhängig vom Wert des Schlüssels &quot;type&quot;: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> Wenn der empfangene &quot;type&quot; &quot;register&quot; war, enthält dieser Schlüssel die Geräte-Registrierungs-ID für Remote-Benachrichtigungen. </li><li> <b>&quot;data&quot;:</b> Wenn der empfangene &quot;type&quot; &quot;local&quot; oder &quot;remote&quot; ist, enthält dieser Schlüssel die Zeichenfolgennutzlast, die Sie beim Aufruf der Benachrichtigungsfunktion definiert haben. </li></ul> Um dies besser zu verstehen, haben wir unten ein kleines Beispiel-Snippet erstellt. In diesem Beispiel senden wir eine lokale Push-Benachrichtigung mit dem folgenden Code: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Dadurch wird ein Timer eingestellt, der eine Benachrichtigung an das Gerät sendet, wenn ein Tag vergangen ist. Wenn der Tag abgelaufen ist, wenn Ihr Spiel entweder im Hintergrund läuft oder nicht läuft, wird dem Benutzer eine Benachrichtigung mit dem angegebenen Titel und der Nachricht (auf iOS wird der Name des Spiels angezeigt und der Titel wird ignoriert) und dann angezeigt Ein asynchrones Push-Benachrichtigungsereignis wird aufgerufen. Wenn sich das Spiel im Vordergrund befindet, wenn die Zeit für die Benachrichtigung angezeigt wird, wird es <i>nicht</i> angezeigt, aber das asynchrone Ereignis <b>wird weiterhin ausgelöst</b>. Im Ereignis selbst würden Sie den Callback so behandeln: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Speichern / Laden</label> <input id="eleven"
type="checkbox"><div class="index_list"> Dieses Ereignis wird durch bestimmte Funktionen ausgelöst, die mit dem Laden und Speichern von Puffern in Dateien sowie dem Laden oder Entladen von Audiodaten aus dem Speicher verbunden sind. Das Ereignis selbst enthält das eingebaute <tt>async_load</tt> DS-Karte, die mit den für die spezifische Funktion erforderlichen Schlüsseln gefüllt wird. Diese sind in den folgenden Abschnitten aufgeführt. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Puffer</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Wenn Sie die Funktionen verwenden <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> Ein asynchrones Ereignis wird ausgelöst, wenn die Datenübertragung abgeschlossen ist. Dieses Ereignis füllt die <tt>async_load</tt> Karte mit den folgenden Schlüssel / Wert-Paaren <br><br><ul><li> <b>&quot;id&quot;:</b> Die ID der Async-Funktion, wie sie von der verwendeten Funktion zurückgegeben wird. </li><li> <b>&quot;status&quot;:</b> wird zurückkehren <tt>true</tt> wenn die Daten korrekt gespeichert / geladen wurden, und <tt>false</tt> Andernfalls. </li></ul> Auf diese Weise können Sie den Lade- / Ladevorgang abfragen und nach Abschluss des Vorgangs eine Nachricht anzeigen oder Räume usw. ändern. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Audiogruppen</label> <input id="thirty" type="checkbox"><div class="index_list"> Wenn Sie mit <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">Audio Groups arbeiten</a>, können Sie sie laden und mithilfe der Funktionen aus dem Speicher entladen <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> und <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Bei Verwendung der Ladefunktion wird dieses Ereignis ausgelöst, wenn der gesamte für die Gruppe festgelegte Satz von Audiodateien in den Speicher geladen wurde und die Karte mit den folgenden Schlüssel / Wert-Paaren gefüllt wird: <br><br><ul><li> <b>&quot;Typ&quot;:</b> Dies sagt uns den Typ des aufgerufenen Ereignisses und wird &quot; <tt>audiogroup_load</tt> &quot;zum Laden von Audio. </li><li> <b>&quot;group_id&quot;:</b> gibt die ID der <b>Audiogruppe</b> zurück, die geladen wurde (wie im <b>Audiogruppen-</b> <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">Editor definiert</a> ). </li></ul> Wenn alle Audiodateien für eine Gruppe geladen wurden, wird dieses Ereignis ausgelöst und kann dann verwendet werden, um Räume zu wechseln oder einen Musiktitel usw. abzuspielen. </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Sozial</label> <input id="eight" type=
"checkbox"><div class="index_list"> Dieses Ereignis kann nur durch die verschiedenen spezifischen <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">sozialen Funktionen</a> ausgelöst werden und gibt ein <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die je nach Rückruf von der Funktion, die das Ereignis ausgelöst hat, verschiedene Schlüssel / Wert-Paare enthält. <br><br> Die ds_map enthält eine Anzahl von Schlüsseln, von denen der wichtigste der Schlüssel &quot; <i>id</i> &quot; ist. Dies wird eine <b>Konstante zurückgeben,</b> die dann im Code überprüft werden kann, um festzustellen, welche der vielen Rückrufe das Ereignis empfangen hat. Nachdem Sie diesen Schlüssel analysiert und den zurückgegebenen Wert mit den verfügbaren Konstanten verglichen haben, können Sie den Rest der Informationen aus der Karte extrahieren. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Bestenlisten und Erfolge</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Auf den Funktionsseiten zu <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">Social Gaming - Achievements und Leaderboards</a> im Abschnitt Referenz werden die Funktionen und Callbacks sowie die Konstanten beschrieben, die zum Auslösen dieses Ereignisses verwendet werden. Es gibt jedoch auch bestimmte Umstände, unter denen es ohne Funktionsaufruf aus dem Spiel ausgelöst wird läuft: <br><br><ul><li> wenn dein Spiel über das Betriebssystem-Dashboard gestartet wird </li><li> wenn du eine Herausforderung beendest </li><li> wenn ein anderer Spieler eine Herausforderung abschließt </li><li> wenn das Spiel vom Betriebssystem-Dashboard gestartet wird, indem eine Herausforderung ausgewählt wird </li></ul><p> Jeder der oben genannten Rückrufe löst das <b>Social Event aus</b> und ein <tt>async_load</tt> Karte wird mit den folgenden Details generiert (beachten Sie, dass es einen anderen Schlüsselwert &quot;ID&quot; gibt, um jeden der verschiedenen Gründe zu definieren, aus denen das Ereignis aufgerufen wurde, aber alle anderen Inhalte der Karte sind gleich): <br><br></p><ul><li> &quot; <b>id</b> &quot; - Der Wert dieses Schlüssels hängt von der Art des Rückrufs ab, der das Ereignis auslöst. Es kann eine dieser Konstanten sein: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Eine Herausforderung wurde erhalten <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Eine Herausforderung wurde abgeschlossen. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Eine Herausforderung wurde vom anderen Spieler ausgeführt. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - Das Spiel wurde vom OS-Dashboard mit der gegebenen Herausforderung gestartet. <br></li></ul></li><li> &quot; <b>playerid</b> &quot; - Die Spieler-ID für die Herausforderung. <br><br></li><li> &quot; <b>issuerid</b> &quot; - Die ID der Person, die die Herausforderung <b>ausgelöst hat</b>. <br><br></li><li> &quot; <b>state</b> &quot; - Der Status der Abfrage, der einen Wert von 0 - 3 (als Zeichenfolge) für <i>ungültig</i>, <i>ausstehend</i>, <i>abgeschlossen</i> oder <i>abgelehnt hat</i>. <br><br></li><li> &quot; <b>Nachricht</b> &quot; - Die Textnachricht für die Herausforderung. <br><br></li><li> &quot; <b>Ausgabedatum</b> &quot; - Das Ausgabedatum für die Herausforderung <br><br></li><li> &quot; <b>completeddate</b> &quot; - Das Fertigstellungsdatum für die Challenge. <br><br></li><li> &quot; <b>type</b> &quot; - Die Art der gestellten Aufgabe. Kann eine von zwei Konstanten sein: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Eine Herausforderung basierend auf dem Score-Wert. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Eine Herausforderung basierend auf einer Leistung. <br></li></ul></li><li> &quot; <b>identifier</b> &quot; - Der identifizierende String für die Challenge. <br><br></li><li> &quot; <b>score</b> &quot; - Die Punktzahl ist mit der Herausforderung verbunden. </li></ul> Im Folgenden finden Sie ein kleines Codeschnipsel als Beispiel für die Verwendung: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Einige der <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">Facebook-Funktionen</a> lösen ein asynchrones soziales Ereignis aus und erstellen ein <tt>ds_map</tt> mit einigen spezifischen Informationen. Die zurückgegebenen Informationen hängen vom &quot;Typ&quot; des Ereignisses ab, das aufgerufen wurde. Sie können dies überprüfen, indem Sie den Schlüssel &quot;type&quot; aus der ds_map lesen, der die folgende Zeichenfolge für ein Facebook-Ereignis sein wird: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Wenn das Ereignis ausgelöst wird und von diesem Typ ist, gibt es auch zusätzliche Schlüssel, die überprüft werden können: </p><ul><li> &quot; <b>requestId</b> &quot; - Der von der <tt>facebook_request_xxx_permission()</tt> Funktion, die das Ereignis ausgelöst hat <br><br></li><li> &quot; <b>Ergebnis</b> &quot; - Dies ist einer der folgenden Strings: <br><br><ul><li> &quot; <b>gewährt</b> &quot; - Erlaubnis (en) wurden vom Benutzer akzeptiert </li><li> &quot; <b>verweigert</b> &quot; - eine oder mehrere Berechtigungen wurden vom Benutzer nicht akzeptiert </li><li> &quot; <b>Fehler</b> &quot; - ein Fehler ist aufgetreten </li></ul></li><li> <b>&quot;error</b> &quot; - Dies wird eine Beschreibung des Fehlers enthalten, ist aber <i>nur</i> vorhanden, wenn &quot; <b>result</b> &quot; = &quot; <b>error</b> &quot; ist. </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Dieses Ereignis kann nur von den <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html"><span class="notranslate">Steam</span> API-</a> Funktionen ausgelöst werden und gibt a zurück <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die abhängig vom Rückruf der Funktion, die das Ereignis ausgelöst hat, verschiedene Schlüssel / Wert-Paare enthält. Die Karte enthält immer den Schlüssel &quot; <b>event_type</b> &quot;, der dann analysiert werden kann, um den Typ der Funktion zu finden, die das Ereignis ausgelöst hat, und den für die Anpassung erforderlichen Code zu ändern. <br><br> Wenn eine Funktion aufgerufen wird, die dieses Ereignis auslöst, wird ein eindeutiger asynchroner ID-Wert generiert, der in einer Variablen gespeichert und überprüft werden soll <tt>async_load</tt> Karte enthält immer einen ID-Schlüssel, den Sie dann analysieren können, und stellen Sie sicher, dass Sie auf das richtige Ereignis reagieren. Tatsächlich enthält die Karte <i>immer</i> die folgenden Tasten, unabhängig von der <span class="notranslate">Steam</span> Funktion, die zum Generieren der asynchronen Antwort verwendet wird: <br><br><ul><li> &quot; <b>id</b> &quot; - Die asynchrone ID, die von der Funktion zurückgegeben wurde, die das Ereignis ausgelöst hat </li><li style="list-style: none"><br></li><li> &quot; <b>Ergebnis</b> &quot; - Das Ergebnis der Operation (ein realer Wert). Dies ist entweder die GML-Konstante <tt>ugc_result_success</tt> oder eine andere reelle Zahl. Sie sollten also nach dieser Konstante suchen, um sicherzustellen, dass der Aufruf erfolgreich war und ansonsten etwas nicht korrekt funktioniert hat. Der Rest der möglichen Werte wird als Ergebnis des <span class="notranslate">Steam</span> &quot;EResult&quot; -Werts angezeigt und Sie sollten sehen <tt>steamclientpublic.h</tt> in den SDK-Headern für alle 89 möglichen Werte. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Eine Zeichenfolge, die den Typ des Ereignisses angibt (Details siehe unten) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Daten hochladen</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Wenn Sie die <span class="notranslate">Steam</span> Funktionen zum Hochladen einer Bestenliste verwenden (entweder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) das zurückgegebene <tt>ds_map</tt> wird die folgenden Schlüssel / Wert-Paare haben: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>leaderboard_upload</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot; - Dieser Schlüssel sollte mit dem ID-Wert übereinstimmen, der von der Funktion zum Hochladen von Aufrufen zurückgegeben wird </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot; - Dieser Schlüssel enthält den Namen der Bestenliste, auf die gepostet wurde </li><li style="list-style: none"><br></li><li> &quot; <b>Erfolg</b> &quot; - Wird 1, wenn der Beitrag erfolgreich war, 0 fehlgeschlagen </li><li style="list-style: none"><br></li><li> &quot; <b>aktualisiert</b> &quot; - Wird 1, wenn der Ranglistenpunkt tatsächlich aktualisiert wurde (dh der neue Punktestand war besser) oder 0, andernfalls </li><li style="list-style: none"><br></li><li> &quot; <b>score</b> &quot; - Dieser Schlüssel enthält den Punktestand, der gepostet wurde </li></ul> Sie können Beispiele auf den Seiten für die Funktionen zum Hochladen von Punkten sehen. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Herunterladen von Bestenlisten</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Bei Verwendung der <span class="notranslate">Steam</span> Funktionen zum Herunterladen einer Bestenliste ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>, <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) das zurückgegebene <tt>ds_map</tt> wird die folgenden Schlüssel / Wert-Paare haben: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>leaderboard_download</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot; - Dieser Schlüssel sollte mit dem ID-Wert übereinstimmen, der von der Download-Aufruffunktion zurückgegeben wird </li><li style="list-style: none"><br></li><li> &quot; <b>status</b> &quot; - Der Status des Rückrufs, wobei -1 einem Fehler entspricht oder dass keine Ergebnisse zurückgegeben wurden und 0 einem Erfolg entspricht. </li><li> &quot; <b>lb_name</b> &quot; - Dieser Schlüssel enthält den Namen der Bestenliste, auf die gepostet wurde </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot; - Die Anzahl der &quot;Zeilen&quot; der Ranglistendaten, die zurückgegeben werden. </li><li style="list-style: none"><br></li><li> &quot; <b>entries</b> &quot; - Eine JSON-Objekt-Zeichenfolge, die eine andere ds_map enthält, die entweder den Schlüssel &quot;default&quot; (bedeutet, dass keine Ergebnisse enthalten sind) oder den Schlüssel &quot;entries&quot; enthält, auf den Sie dann den Wert erhalten können. Dieser Rückgabewert für &quot;Einträge&quot; ist a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> enthält jeden der Ränge von der Rangliste, wobei jeder Eintrag in der Liste sich selbst auf einen anderen bezieht <tt>ds_map</tt> Diese enthält die Schlüssel &quot;name&quot;, &quot;score&quot; und &quot;rank&quot; und kann je nach der zum Hochladen verwendeten Funktion auch eine &quot;data&quot; -Taste enthalten. </li></ul> Wir zeigen ein Beispiel für das Herunterladen von Score-Daten, indem wir die Top-Ten-Rangliste für die gegebene Rangliste anfordern und deren Ergebnisse im <b><span class="notranslate">Steam</span> Async-Event analysieren</b> (Beispiele zum Hochladen finden Sie auf den entsprechenden Funktionsseiten). Zunächst müssen wir die Punkte mit dem folgenden Code anfordern: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Dies sendet eine Anfrage an den <span class="notranslate">Steam</span> Server für die Punkte aus der Bestenliste &quot;Spielstände&quot; und speichert die <b>asynchrone ID</b> der Anfrage in der Variablen &quot;score_get&quot;. Dies wird dann im <b><span class="notranslate">Steam</span> Async-Ereignis</b> folgendermaßen gehandhabt: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Was wir hier machen, ist zuerst die &quot;ID&quot; -Taste des Specials zu überprüfen <tt>async_load</tt> Karte. Wenn dieser Wert dem Wert der ursprünglichen Rückruffunktion entspricht (gespeichert in der Variable &quot;score_get&quot;), verarbeiten wir die Daten weiter. Das erste, was wir tun, ist zu analysieren <tt>async_load</tt> ds_map für den Schlüssel &quot;entries&quot;, der ein JSON-Objekt enthält, das die Leaderboard-Daten enthält. Dieses JSON-Objekt wird dann dekodiert (siehe <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) als eine weitere ds_map, und diese neue Karten-ID wird in der Variablen &quot;map&quot; gespeichert. <br><br> Diese Karte wird auf den Schlüssel &quot;default&quot; überprüft und wenn das gefunden wird, wird die Karte zerstört und das Ereignis wird beendet. Wenn kein &quot;Standard&quot; -Schlüssel gefunden wird, parst der Code die Karte, um die notwendigen Informationen über das Leaderboard zu extrahieren, indem zuerst eine ds_list aus dem &quot;entries&quot; -Schlüssel der ds_map extrahiert und dann durch jeden Eintrag der Liste zu Holen Sie sich eine <i>weitere</i> ds_map mit dem Namen, der Punktzahl und dem Rang jedes Eintrags. Diese Werte werden dann in Arrays gespeichert und dann prüfen wir, ob es einen zusätzlichen &quot;Daten&quot; -Schlüssel gibt. Wenn dies der Fall ist (dh der Punktestand wurde mit einem zusätzlichen Datenpaket hochgeladen), analysieren wir auch diesen und senden ihn zum Debuggen an die Compiler-Konsole, bevor wir den Puffer zerstören und dann fortfahren, um die Karte zu zerstören. Beachten Sie, dass, wenn der Schlüssel &quot;data&quot; enthalten ist, dieser mit dem Befehl decodiert werden muss <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> bevor es richtig gelesen werden kann. <br><br> Sobald die Schleife beendet ist, wird die Eintragsliste zerstört, ebenso wie die Karte, von der sie genommen wurde. Es besteht keine Notwendigkeit, das zu zerstören <tt>async_load</tt> ds_map, da dies von <i><span class="notranslate">GameMaker Studio 2</span></i> für Sie erledigt wird. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Herunterladen von UGC (benutzergenerierter Inhalt)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Wenn Sie die <span class="notranslate">Steam</span> Funktionen zum Herunterladen von <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">User Generated Content (UGC) verwenden</a>, löst eine Anzahl von ihnen dieses Ereignis aus. Jede Funktion generiert jedoch ein <tt>async_load</tt> ds_map mit unterschiedlichen Schlüssel / Wert-Paaren (obwohl sie immer die allgemeinen Schlüssel &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; und &quot; <b>event_type</b> &quot; enthalten), so <b>lesen</b> Sie bitte die Seite, die für die Funktion spezifisch ist, für Details und Beispiele. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Einzigartige UGC-Ereignisse</label> <input id="twentysix" type="checkbox"><div class="index_list"> Das <span class="notranslate">Steam</span> Async-Ereignis kann auch ausgelöst werden, wenn ein Benutzer ein Element außerhalb des Spiels abonniert - beispielsweise indem er in einen Browser wechselt und ein neues Element abonniert und dann zurück zum Spiel wechselt. In diesen Fällen <tt>async_load</tt> Die Karte enthält <b>nur</b> die folgenden Details (und keine der Standardwerte, die oben auf dieser Seite aufgeführt sind): <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot; - die ID des neu installierten UGC-Elements (Sie können die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> um den Pfad zum installierten Artikel zu erhalten) </li><li style="list-style: none"><br></li></ul> Das <span class="notranslate">Steam</span> Async-Ereignis kann auch ausgelöst werden, wenn ein Workshop-Artikel abonniert wurde - entweder von der App aus oder extern von einem Workshop-Browser aus - und in diesen Fällen der <tt>async_load</tt> map enthält die folgenden Schlüssel / Wert-Paare: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: Dieser Schlüssel enthält die veröffentlichte Datei-ID des neu abonnierten Elements </li><li style="list-style: none"><br></li></ul> Das Ereignis wird ausgelöst, wenn ein Artikel auch nicht abonniert wurde und die DS-Karte Folgendes enthält: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_unsubscribed&quot;</b> &quot;&quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: Dieser Schlüssel enthält die veröffentlichte Datei-ID des nicht abonnierten Elements </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">System</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Dieses Ereignis kann nur durch ein Ereignis auf Systemebene ausgelöst werden (z. B. die Erkennung eines Gamepads oder die automatische Anmeldung bei XBox Live) <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die abhängig vom Ereignis auf Systemebene, das den Rückruf ausgelöst hat, unterschiedliche Schlüssel / Wert-Paare enthält. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Spiel-Pads</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Wenn dieses Ereignis ausgelöst wird, wenn ein Gamepad verbunden oder getrennt wird, gibt es eines der folgenden Schlüssel / Wert-Paare in der <tt>async_load</tt> Karte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - der Typ des empfangenen Systemereignisses, bei dem es sich um eine der folgenden Zeichenfolgen handelt: <br><br><ul><li> &quot; <b>Gamepad entdeckt</b> &quot; - passiert, wenn das System meldet, dass ein neues Gamepad angeschlossen wurde </li><li> &quot; <b>Gamepad verloren</b> &quot; - tritt auf, wenn das System die Verbindung zu einem Gamepad verloren hat </li></ul></li><li> &quot; <b>pad_index</b> &quot; - der Index des Pad, der hinzugefügt oder entfernt wurde </li></ul><p> Dieses Ereignis erlaubt es Ihnen nun, all Ihre Gamepad-Prüflogik vom Step-Event oder einem Alarmereignis in das System-Event zu verschieben und es nur dann auszuführen, wenn es tatsächlich benötigt wird. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">XBox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> Das asynchrone Systemereignis kann ausgelöst werden, wenn Sie mit dem <b>UWP-</b> Export auf die <b><span class="notranslate">XBox One</span></b> abzielen und die Option &quot; <b>Enable XBox Live</b> &quot; in den <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">UWP-Spieloptionen aktivieren</a>. Wenn Sie das UWP-Projekt von <i><span class="notranslate">GameMaker Studio 2</span></i> starten, für das Xbox Live aktiviert ist, versucht das Projekt automatisch, sich automatisch bei Xbox Live anzumelden. Die Ergebnisse dieses Anmeldeversuchs werden als eines der folgenden Schlüssel / Wert-Paare in der zurückgegeben <tt>async_load</tt> Karte: </p><ul><li> &quot; <b>event_type</b> &quot; - der Typ des empfangenen Systemereignisses, bei dem es sich um eine der folgenden Zeichenfolgen handelt: <br><br><ul><li> &quot; <b>Benutzer angemeldet</b> &quot; - die automatische Benutzeranmeldung wurde erfolgreich abgeschlossen </li><li> &quot; <b>Benutzeranmeldung fehlgeschlagen</b> &quot; - die Anmeldung des Benutzers ohne Benutzereingaben ist fehlgeschlagen (in diesem Fall können Sie die Funktion verwenden) <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> um den Benutzer zur Auswahl eines Kontos zu veranlassen, mit dem er sich anmelden möchte) </li><li> &quot; <b>Benutzer abgemeldet</b> &quot; - der Benutzer hat sich abgemeldet </li></ul></li></ul><p> Weitere Informationen zu den spezifischen Funktionen von XBox Live finden Sie <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">hier</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="../objects.html">Der Objekt-Editor</a> </div><div style="float:right"> Weiter: <a href="draw_events.html">Ereignisse zeichnen</a> </div></div></div><h5> © Urheberrecht <span class="notranslate">YoYo Games Ltd.</span> 2017 Alle Rechte vorbehalten </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
