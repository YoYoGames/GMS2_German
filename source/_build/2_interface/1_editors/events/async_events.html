<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Die asynchronen Ereignisse </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Objekteditor Async-Ereignisse"> Ein <b>asynchrones Ereignis</b> wird ausgelöst, wenn <i><span class="notranslate">GameMaker Studio 2</span></i> einen Rückruf von einer externen Quelle erhält, die aus dem Internet oder von dem Gerät stammt, auf dem das Spiel ausgeführt wird. Grundsätzlich sagen Sie <i><span class="notranslate">GameMaker</span> Studio 2</i>, dass es etwas tun soll, beispielsweise ein Bild laden, und es beginnt damit, aber machen Sie weiter, was es sonst noch tun muss, während es funktioniert. Wenn die Anforderung abgeschlossen ist, wird ein Rückruf an <i><span class="notranslate">GameMaker Studio 2</span></i> gesendet, und alle für diesen <b>Rückruftyp</b> definierten <b>asynchronen Ereignisse</b> werden ausgelöst. Bitte beachten Sie, dass die asynchronen Ereignisse für <i>alle</i> Instanzen ausgelöst werden, in denen sie vorhanden sind, ähnlich wie bei den Schlüsselereignissen <tt>http_get</tt> Aufruf in einer Instanz, haben jedoch das asynchrone HTTP-Ereignis in einer anderen Instanz, um den Rückruf abzuwickeln. <br></p><div class="note"> <b>ANMERKUNG</b>: Sie sollten wissen, dass aufgrund des XSS-Schutzes in Browsern Anforderungen an und Versuche zum Laden von Ressourcen aus verschiedenen Domänen blockiert werden und bei Verwendung der folgenden Ereignisse möglicherweise leere Ergebnisse zurückgeben </div><p><br> Mit der asynchronen Ereigniskategorie sind verschiedene Ereignistypen verknüpft, die in den folgenden Abschnitten erläutert werden: </p><div class="note"> <b>HINWEIS:</b> Die Variable <tt>async_load</tt> was in den folgenden Abschnitten erwähnt wird, gilt <b>nur für diese Ereignisse</b> als <tt>ds_map</tt> Das heißt Punkte zu, die zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht werden, wobei diese Variable zu allen anderen Zeitpunkten auf den Wert -1 zurückgesetzt wird. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Audiowiedergabe</label> <input id="thirteen" type="checkbox"><div class="index_list"> Dieses Ereignis kann nur durch die <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">Wiedergabefunktionen</a> der <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">Audio-Warteschlange</a> ausgelöst werden und gibt ein zurück <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, enthält verschiedene Schlüssel / Wert-Paare in Bezug auf die Audiowarteschlange, die das Ereignis ausgelöst hat. Das Ereignis wird ausgelöst, wenn Sie eine Audiowarteschlange für die Wiedergabe ausgewählt haben und ein Puffer in dieser Audiowarteschlange abgespielt ist. <br><br> Die folgenden Schlüssel sind in der ds_map verfügbar: <br><br><ul><li> &quot; <b>queue_id</b> &quot; - der Warteschlangenindex für die Warteschlange, die beendet wurde, wie von der Funktion zurückgegeben <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot; - die Puffer-ID für den Puffer, von dem nicht mehr gespielt wird </li><li> &quot; <b>queue_shutdown</b> &quot; - dieser <b>Wert</b> wird bei normaler Wiedergabe auf 0 und bei Empfang des Ereignisses auf 1 gesetzt, weil <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> genannt worden. Wenn dieser Wert auf 1 gesetzt ist, möchten Sie keine weiteren Daten in die Warteschlange stellen. </li></ul> Da eine Audiowarteschlange aus mehreren Puffern erstellt werden kann, kann dieses Ereignis für eine Warteschlange mehrmals ausgelöst werden, wenn das Ende jedes Abschnitts gepufferten Audios erreicht wird, daher die Taste &quot;buffer_id&quot;. <br><br><div class="note"> <b>HINWEIS:</b> Die Variable <tt>async_load</tt> ist nur in den asynchronen Ereignissen gültig, da das <tt>ds_map</tt> Das heißt Punkte zu, die zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht werden, wobei diese Variable auf den Wert -1 zurückgesetzt wird. Alle weiteren Datenstrukturen, die aus dem Ereignis erstellt werden, <b>müssen jedoch mit den entsprechenden Funktionen aufgeräumt werden</b>. </div><br> In dem unten angegebenen Anwendungsbeispiel erstellen wir eine Audio-Warteschlange mit 10 hinzugefügten gepufferten Audio-Sounds und spielen dann die Warteschlange ab: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Jeder Spielschritt, in dem die Aufzeichnung erkannt wird, löst ein asynchrones Audio-Aufzeichnungsereignis aus, bei dem Sie die aufgenommenen Eingaben wie folgt behandeln können: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Hier überprüfen wir die Warteschlangen-ID. Wenn es die gewünschte ist, überprüfen wir die Puffer-ID, um festzustellen, welcher Puffer vollständig abgespielt wurde. Wir setzen dann eine lokale Variable auf diesen Indexwert, um sie später zu überprüfen, und setzen den Puffer für diesen Sound wieder auf den Anfang. Sobald unsere lokale Variable 9 erreicht hat, was bedeutet, dass die Warteschlange beendet ist, stoppen wir den Sound und geben die Warteschlange frei. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Audio Aufnahme</label> <input id="twelve"
type="checkbox"><div class="index_list"> Dieses Ereignis kann nur vom ausgelöst werden <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> Funktion und wird ein zurückgeben <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die unterschiedliche Schlüssel / Wert-Paare enthalten, abhängig vom Rückruf der Funktion, die das Ereignis ausgelöst hat. <br><br> Die folgenden Schlüssel sind in der ds_map verfügbar: <br><br><ul><li> &quot; <b>buffer_id</b> &quot; - die ID des temporären Puffers, mit dem Sie die Audiodaten abrufen können </li><li> &quot; <b>channel_index</b> &quot; - der Aufzeichnungskanalindex, wie er von der aufrufenden Funktion zurückgegeben wird, von der diese Daten stammen </li><li> &quot; <b>data_len</b> &quot; - die Länge der Daten (in Byte), die Sie erhalten haben </li></ul><div class="note"> <b>HINWEIS:</b> Wie am Anfang dieser Seite erwähnt, die Variable <tt>async_load</tt> ist nur in den asynchronen Ereignissen gültig, da das <tt>ds_map</tt> Das heißt Punkte zu, die zu Beginn des Ereignisses erstellt und am Ende wieder gelöscht werden. Beachten Sie jedoch, dass der temporäre Puffer, in dem das gesamte Audio mit der Karte gespeichert ist, auch am Ende des Ereignisses entfernt wird. Sie sollten ihn also in einen benutzerdefinierten Puffer kopieren, wenn Sie ihn zur späteren Verwendung aufbewahren möchten. </div><br> Im nachstehenden Verwendungsbeispiel erstellen wir einen benutzerdefinierten Puffer zum Speichern unserer aufgenommenen Audiodaten und stellen auch unser Spiel so ein, dass es von der Eingangsquelle 0 aufzeichnet: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Jeder Spielschritt, in dem die Aufzeichnung erkannt wird, löst ein asynchrones Audio-Aufzeichnungsereignis aus, bei dem Sie die aufgenommenen Eingaben wie folgt behandeln können: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Hier überprüfen wir einfach den Schlüssel &quot;channel_index&quot;, um sicherzustellen, dass er mit dem Wert übereinstimmt, der bei Beginn der Aufzeichnung zurückgegeben wurde. Wenn dies der Fall ist, kopieren wir den Inhalt des für dieses Ereignis erstellten temporären Puffers in unseren benutzerdefinierten Puffer. Danach können Sie mit dem benutzerdefinierten Puffer tun, was Sie möchten - Sie können ihn mit den speziellen Puffer-Audiofunktionen abspielen, Sie können ihn bearbeiten und über das Netzwerk senden, Sie können ihn auf der Festplatte speichern... Sobald Sie Ihr Audio aufgenommen haben In einem Puffer können Sie grundsätzlich alles tun, was Sie möchten. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Wolke</label> <input id="five" type="checkbox"><div class="index_list"> Das Cloud-Ereignis wird durch den Rückruf von einem der Teilnehmer ausgelöst <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> Funktionen</a> wie <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. Es erzeugt tatsächlich eine <tt>ds_map</tt> das ist exklusiv für dieses Ereignis und wird in der speziellen Variablen <b>async_load</b> gespeichert (siehe die einzelnen Funktionen für Codebeispiele, die die Verwendung dieses Ereignisses detaillierter erklären). Diese ds_map hat folgende Struktur: <br><br><ul><li> <b>&quot;status&quot;:</b> Hier ist der Statuscode enthalten, wobei ein negativer Wert einen Fehler bezeichnet, dessen Beschreibung im &quot;errorString&quot; enthalten ist. Ein Wert von 0 (oder ein positiver Wert) zeigt einen Erfolg an (genaue Werte siehe unten), und der &quot;resultString&quot; enthält die zurückgegebenen Daten oder eine Erfolgsmeldung. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die ID, die von der aufgerufenen Funktion zurückgegeben wurde. Wenn Sie eine Reihe von feuern <tt>cloud_</tt> Wenn Sie also Anforderungen eingeben, müssen Sie wissen, auf welche Sie die Antwort erhalten, und daher würden Sie diesen Wert verwenden, um den Wert zu vergleichen, den Sie gespeichert haben, als Sie die Anfrage ursprünglich gesendet hatten, um den richtigen zu finden. </li><li style="list-style: none"><br></li><li> <b>&quot;description&quot;:</b> Die Beschreibung der zuletzt hochgeladenen Datei. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;:</b> Dies enthält einen String, der aus der Cloud zurückgegebene Datenblob ist. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;: Gibt</b> eine <b>Fehlerzeichenfolge</b> für einen Fehler zurück. </li></ul> Die genaue Bedeutung des zurückgegebenen &quot;status&quot; -Karteneintrags wird in der folgenden Tabelle erläutert: <div class="compat"><table><tr><th> Statuswert </th><th> errorString / resultString </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;Nicht bei &lt;SERVICE&gt; angemeldet&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = wiederhergestellte Daten </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;AlreadySynchronized&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Fehlerbeschreibung </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Dialog</label> <input id="three" type=
"checkbox"><div class="index_list"> Wie die oben genannten Ereignisse wird das <b>Dialoges-</b> Ereignis nur ausgelöst, wenn es von einer der speziellen asynchronen Benutzerfunktionen (z. B.) zurückgerufen wird <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (In dieser Funktion finden Sie ein erweitertes Codebeispiel, wie dieses Ereignis verwendet wird.) Bei diesen Ereignissen werden bestimmte Benutzereingaben verlangt, z. B. Name, Anmeldedaten, Nummer oder Farbe usw. Da die meisten Geräte nicht gerne in einer Schleife sitzen und auf eine Antwort warten, müssen sie dies tun asynchron sein und <i><span class="notranslate">GameMaker Studio 2</span></i> wird im Hintergrund weiterlaufen, während für diese Funktionen ein Dialogfeld geöffnet ist und bis sie die erforderliche Benutzereingabe erhalten, die dieses Ereignis auslöst. <br><br> Wieder a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> wird mit der ID zurückgegeben, die in der speziellen Variablen <b>async_load gespeichert ist</b>. Die Werte in dieser Karte hängen von der verwendeten Funktion ab. Weitere Informationen finden Sie in den einzelnen Einträgen für jede Funktion in diesem Handbuch. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> Das HTTP-Ereignis ist ein Ereignis, das durch den Rückruf von einem der ausgelöst wird <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> Funktionen</a> wie <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. Es erzeugt tatsächlich eine <tt>ds_map</tt> (manchmal auch als &quot;Wörterbuch&quot; bezeichnet), das sich ausschließlich auf dieses Ereignis bezieht und in der speziellen Variablen gespeichert wird <tt>async_load</tt> (In den einzelnen Funktionen finden Sie Codebeispiele, die die Verwendung dieses Ereignisses näher erläutern.) Diese <tt>ds_map</tt> hat folgende Struktur: <br><br><ul><li> <b>&quot;id&quot;:</b> Die ID, die vom Befehl zurückgegeben wurde. Wenn Sie eine Reihe von feuern <tt>http_</tt> Wenn Sie also Anforderungen eingeben, müssen Sie wissen, auf welche Sie die Antwort erhalten, und daher würden Sie diesen Wert verwenden, um den Wert zu vergleichen, den Sie gespeichert haben, als Sie die Anfrage ursprünglich gesendet hatten, um den richtigen zu finden. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Gibt einen Wert unter 0 für einen Fehler, 0 für den Erfolg und 1 für den Inhalt zurück. </li><li style="list-style: none"><br></li><li> <b>&quot;Ergebnis&quot;:</b> Die empfangenen Daten (nur Zeichenfolge) oder der Pfad zur heruntergeladenen Datei, falls Sie diese verwendet haben <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;:</b> Die von Ihnen angeforderte vollständige URL. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> Der <b>unformatierte</b> http-Statuscode (falls verfügbar). Dies gibt den Standard-Webstatuscode für die meisten Browser zurück, zB: 304 für &quot;Not Modified&quot; oder 204 für &quot;No Content&quot; usw. </li></ul> Das ist für, wenn Sie die verwenden <tt>http_post_string()</tt> Funktion, aber jeder der <tt>http_</tt> Funktionen können eine leicht abweichende Karte zurückgeben. Informationen zu den für diese Funktion zurückgegebenen Daten finden Sie in der manuellen Eingabe der einzelnen Funktionen. <br><br><div class="note"> <b>HINWEIS:</b> als <tt>async_load</tt> schafft ein <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> Diese Funktionen sind besonders nützlich, wenn sie mit der <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> und <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> Funktionen. </div><br><br> Wenn Sie Dateien zum Herunterladen angefordert haben, könnte diese Karte weitere Daten enthalten. In diesem Fall hat der &quot;Status&quot; den Wert 1 und die ds_map enthält diese zusätzlichen Schlüssel: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> Dies ist die Größe der Datei, die der Web-Server erwartet hat, die Sie erwarten sollen (möglicherweise -1, wenn der Server diese Daten nicht <b>zurückgibt</b> ). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> Die Größe der Daten, die bereits heruntergeladen wurden. </li></ul> Beachten Sie, dass das Ereignis <i>nicht</i> für jedes einzelne empfangene Datenpaket ausgelöst wird, sondern dass es während des Herunterladens innerhalb der Hauptspielschleife jederzeit aktualisiert wird. Beachten Sie außerdem, dass diese Funktion derzeit nur für reguläre <i>Windows-</i> Zielplattformen verfügbar ist. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Dieses Ereignis kann nur ausgelöst werden, wenn Sie <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">In-App-Käufe</a> für Ihr Spiel aktiviert haben. Wenn Sie diese Funktionalität hinzugefügt haben, wird das Ereignis unter den folgenden Umständen ausgelöst: <br><br><ul><li> Der Speicherstatus ändert sich. </li><li> Ein Produkt (oder Produkte) wurde aktiviert. </li><li> Das Produkt und die Einkäufe wurden wiederhergestellt. </li><li> Ein Produkt wurde gekauft. </li><li> Ein Produkt wurde verbraucht. </li></ul> Die Veranstaltung wird immer etwas Besonderes schaffen <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> mit einer Index-ID, die in der eingebauten Variablen gespeichert ist <tt><b>iap_data</b></tt>. Diese Map enthält <i>immer</i> den Schlüssel &quot; <b>type</b> &quot;, der einen der folgenden konstanten Werte enthält: <div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Dies wird ausgelöst, wenn im Zielplattformspeicher eine Änderung festgestellt wird. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Dieses Ereignis wird ausgelöst, wenn ein Produkt aktiviert wird und zusätzliche Informationen zum Produkt enthält. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Dieses Ereignis wird nur ausgelöst, wenn Sie das verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> Funktion. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Wenn ein Kauf abgeschlossen ist, wird dieses Ereignis ausgelöst. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Wenn Sie die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> es löst dieses Ereignis aus. </td></tr></table></div><p><br><br> Jeder dieser möglichen Ereignistypen fügt zusätzliche Schlüssel hinzu <tt>iap_data</tt> ds_map, das dann analysiert werden kann, um die erforderlichen Einkaufs- oder Produktinformationen zu erhalten. Der genaue Inhalt der <tt>iap_data</tt> Die Karte ist unten für jeden &quot;Typ&quot; der Veranstaltung aufgelistet. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Wenn Sie Ihre Einkäufe aktivieren, versucht Ihr Spiel, den Zielspeicher zu kontaktieren, wodurch dieses Ereignis ausgelöst wird. Das <tt>iap_data</tt> map hat dann den Zusatzschlüssel &quot; <b>status&quot;</b>, der als Wert eine der folgenden Konstanten hat: <br><br><div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> Der Laden wurde kontaktiert und die Verbindung ist gut. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Es ist ein Verbindungsfehler aufgetreten oder der Store ist aus irgendeinem Grund nicht verfügbar. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Alle aktivierten Einkäufe lösen diesen Ereignistyp aus, jedoch nur einmal pro Kauf. Wenn Sie zehn Produkte aktiviert haben, sollten Sie davon ausgehen, dass dieses Ereignis zehnmal ausgelöst wird. Wenn Sie diese Veranstaltung erhalten haben, <tt>iap_data</tt> ds_map enthält den zusätzlichen Schlüssel &quot; <b>index</b> &quot;, der die eindeutige <b>Produkt-ID-Zeichenfolge</b> für das zu aktivierende Produkt enthält. Sie können dann die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> zusammen mit dieser Produkt-ID erhalten Sie weitere Informationen. <br><br><div class="note"> <b>HINWEIS:</b> Google Play ( <span class="notranslate">Android</span> ) kann nur Details zu Produkten 20 gleichzeitig abfragen, was zu recht langen Ladezeiten für Anwendungen mit einer großen Anzahl von Produkten führen kann. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Wenn Sie die Funktion aufrufen <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> Es löst dieses Ereignis aus und fügt dem Ereignis einen &quot; <b>Ergebnisschlüssel</b> &quot; hinzu <tt>iap_data</tt> ds_map. Diese Taste wird entweder gedrückt halten <tt>true</tt> oder <tt>false</tt> um anzuzeigen, ob die Kaufdaten erfolgreich aus dem Zielspeicher wiederhergestellt wurden. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> Bei Anforderung eines Kaufs über die Funktion <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> Dieser Ereignistyp wird ausgelöst. Das <tt>iap_data</tt> ds_map enthält den zusätzlichen Schlüssel &quot; <b>index</b> &quot;, der den eindeutigen <b>Kauf-ID-</b> Wert für das gekaufte Produkt enthält. Sie können dann die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> zusammen mit dieser Kauf-ID, um weitere Informationen zu erhalten. <br><br><div class="note"> <b>HINWEIS:</b> Wenn das gekaufte Produkt ein Verbrauchsartikel ist, <b>muss es verwendet</b> werden <tt>iap_consume</tt> bevor ein weiterer Kauf getätigt werden kann. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Bei Verwendung der Funktion <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> Dieser Ereignistyp wird ausgelöst. Das <tt>iap_data</tt> ds_map enthält den zusätzlichen Schlüssel &quot; <b>product</b> &quot;, der die eindeutige <b>Produkt-ID-</b> Zeichenfolge für das konsumierte Produkt enthält. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Bild geladen</label> <input id=
"one" type="checkbox"><div class="index_list"> Dieses Ereignis wird ausgelöst, wenn Sie ein Bild in <i><span class="notranslate">GameMaker Studio 2</span></i> laden, sofern Sie eine gültige URL oder einen gültigen Pfad mit der entsprechenden Ladedatei-Funktion verwendet haben. Angenommen, Sie möchten ein Sprite-Image laden und das aktuelle Sprite für die Instanz erst nach dem Laden in das neue ändern. Nun, Sie hätten so etwas in einem Erstellungsereignis oder einem Alarmereignis (zum Beispiel): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Jetzt wird das Bild in das Gerät oder den Browser geladen. <i><span class="notranslate">GameMaker Studio 2</span></i> wird jedoch <i>nicht</i> blockiert, während es auf das Laden der Datei wartet. Stattdessen läuft <i><span class="notranslate">GameMaker</span> Studio 2</i> normal weiter, bis das Image geladen ist und der Rückruf das <b>Image Loaded-</b> Ereignis auslöst, wobei a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> wird erstellt und in der Sondervariable <b>async_load</b> gespeichert. Die Karte enthält folgende Informationen: </p><ul><li> <b>&quot;Dateiname&quot;:</b> Der vollständige Pfad zur angeforderten Datei. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die ID der Ressource, die Sie geladen haben. Dies entspricht der Variablen, der Sie die Ressource zugewiesen haben. </li><li style="list-style: none"><br></li><li> <b>&quot;status&quot;:</b> Gibt für einen Fehler einen Wert unter 0 zurück. </li></ul><p> In diesem Fall würden Sie dann das neu geladene Bild einem Hintergrund zuweisen. Das Obige gilt auch für Sprites und Sounds, wobei für jede dieser Ressourcen eine ds_map generiert wird, wie oben gezeigt. Das folgende Codebeispiel zeigt, wie die zurückgegebenen Informationen in diesem Ereignis verwendet werden: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> Der obige Code überprüft zuerst die ID der erstellten ds_map und dann den Status des Rückrufs. Wenn der Wert größer oder gleich 0 ist (Signalisierungserfolg), wird das Ergebnis des Rückrufs verwendet, um den Hintergrundindex auf das neu geladene Bild festzulegen. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">Vernetzung</label> <input id="six" type=
"checkbox"><div class="index_list"> Das Netzwerkereignis wird vom eingehenden Netzwerkverkehr ausgelöst und ist mit den <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">Netzwerkfunktionen verbunden</a>. Dieses Ereignis generiert eine spezielle <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a>, die für dieses Ereignis exklusiv ist und in der Sondervariable <b>async_load gespeichert wird</b>. Diese <tt>ds_map</tt> enthält je nach Art des Netzwerkereignisses, das es generiert hat, unterschiedliche Informationen. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Häufige Netzwerkereignisse</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Die folgenden Tasten sind für alle empfangenen Netzwerkfunktionen gleich und sind immer im vorhanden <tt>async_load</tt> Karte: <br><br><ul><li> <b>&quot;type&quot;:</b> Dies hat eine der unten aufgeführten Konstanten als Rückgabewert und bezeichnet den Netzwerkereignistyp. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Die Socket-ID (eine reelle Zahl, die von der Funktion <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> oder <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket zurückgegeben</a> wird), die das Ereignis empfängt. In den meisten Fällen ist die zurückgegebene Socket-ID die ID des TCP- oder UDP-Sockets, der das Ereignis ausgelöst hat. Wenn das Ereignis jedoch in einem <i>Server</i> ausgelöst wird und es sich um ein Datenereignis (siehe unten) handelt, ist die Socket-ID diejenige des <i>Clients</i>, der das Ereignis gesendet hat Daten. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> Die IP-Adresse des Sockets (als String). </li><li style="list-style: none"><br></li><li> <b>&quot;port&quot;:</b> Der mit der IP-Adresse verknüpfte Port (nützlich bei der Arbeit mit UDP). </li></ul> Die möglichen Rückgabewerte für den Schlüssel &quot;type&quot; können eine der drei unten aufgelisteten Konstanten sein: <div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> Das Ereignis wurde durch eine Verbindung ausgelöst. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> Das Ereignis wurde durch eine Verbindungsunterbrechung ausgelöst. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> Das Ereignis wurde durch eingehende Daten ausgelöst. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> Das Ereignis wurde von einer als nicht blockierend konfigurierten Verbindung ausgelöst (Sie können die Funktion verwenden.) <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> dafür). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Verbinden / Trennen</label> <input id="twentyone" type="checkbox"><div class="index_list"> Wenn Sie eine Veranstaltung des Typs haben <tt>network_type_connect</tt>. <tt>network_type_non_blocking_connect</tt> oder <tt>network_type_disconnect</tt>, das <tt>async_load</tt> Die Karte enthält die folgenden zusätzlichen Schlüssel: <br><br><ul><li> <b>&quot;socket&quot;:</b> Diese Taste hält die Verbindungs- / Trennbuchsen-ID. </li><li style="list-style: none"><br></li><li> <b>&quot;erfolgreich&quot;:</b> Dieser Schlüssel ist entweder 0 oder 1, wobei 0 die Zeitüberschreitung der Verbindung und 1 bedeutet, dass die Verbindung erfolgreich war und der Socket betriebsbereit ist. </li></ul> Es ist erwähnenswert, dass das Netzwerkereignis nicht in <i>Clients</i> ausgelöst wird, wenn der <i>Server die Verbindung</i> trennt, und dass keine der beiden <tt>network_type_*</tt> Ereignisse werden in Clients ausgelöst, wenn der Server, mit dem sie verbunden sind, die Verbindung trennt, selbst wenn die Verbindung TCP-basiert ist. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Daten empfangen</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Wenn du einen hast <tt>network_type_data</tt> type event, was bedeutet, dass Ihr Netzwerk Daten erhalten hat, die erstellte Karte enthält die folgenden Schlüssel: <br><br><ul><li> <b>&quot;Puffer&quot;:</b> Dies ist die eindeutige &quot;Puffer-ID&quot;, die vom Ereignis generiert wird. Ein Puffer vom Typ &quot;grow&quot; (Byte), der auf 1 ausgerichtet ist, wird erstellt, damit die ID in einer Variablen gespeichert und für alle weiteren Funktionsaufrufe an den Puffer <i><b>in diesem Ereignis verwendet werden kann</b></i>. Genau wie das <tt>async_load</tt> map wird der erstellte Puffer am Ende dieses Ereignisses automatisch aus dem Speicher entfernt. Weitere Informationen zu Puffern finden Sie unter <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Referenzpuffer</a> </li><li style="list-style: none"><br></li><li> <b>&quot;size&quot;:</b> Dies ist die Größe (in Bytes) der Pufferdaten, die empfangen werden. </li></ul><div class="note"> <b>HINWEIS:</b> Der erstellte Puffer ist <b>nur für diese Ereignisse gültig</b> und wird freigegeben, wenn das Ereignis beendet ist. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Push-Benachrichtigung</label> <input id="ten" type=
"checkbox"><div class="index_list"> Das Push-Benachrichtigungsereignis wird durch den Rückruf von <b>Push-Benachrichtigungen</b> im Betriebssystem des Geräts ausgelöst, entweder von einer lokalen Quelle, die die Funktion verwendet <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a> oder von einer entfernten Quelle (z. B. Ihrem Server). Es erzeugt eine <tt>ds_map</tt> das ist exklusiv für dieses Ereignis und wird in der speziellen Variablen <b>async_load</b> gespeichert (siehe die einzelnen Funktionen, die asynchrone Ereignisse für Codebeispiele auslösen, die die Verwendung dieses Ereignisses detaillierter erklären). Diese <tt>ds_map</tt> hat die folgenden Schlüssel: <br><br><ul><li> <b>&quot;Typ&quot;: Der</b> Wert kann für eine lokale Benachrichtigung des Geräts &quot;local&quot; sein, für eine Remote-Benachrichtigung &quot;remote&quot; oder für die Registrierung einer Remote-Benachrichtigung &quot;register&quot;. </li><li> <b>&quot;Status&quot;: Der</b> Wert ist &quot;1&quot; für den Erfolg oder &quot;0&quot; für einen Fehler. </li></ul> Es können zusätzliche Schlüsseleinträge vorhanden sein, die auf dem zurückgegebenen &quot;Typ&quot; und dem &quot;Status&quot; -Wert basieren. Wenn für &quot;Status&quot; ein Fehler zurückgegeben wurde (&quot;0&quot;), erhalten Sie auch den folgenden Schlüssel: <br><br><ul><li> <b>&quot;error&quot;:</b> Enthält Details zum empfangenen Fehler. </li></ul> Wenn der &quot;Status&quot; -Wert 1 ist (dh: keine Fehler), wird der <tt>ds_map</tt> enthält abhängig vom Wert des Schlüssels &quot;type&quot; die folgenden zusätzlichen Werte: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> Wenn der empfangene &quot;Typ&quot; &quot;register&quot; war, enthält dieser Schlüssel die <b>Geräteregistrierungs-</b> ID für Remote-Benachrichtigungen. </li><li> <b>&quot;data&quot;:</b> Wenn der empfangene &quot;type&quot; &quot;local&quot; oder &quot;remote&quot; war, enthält dieser Schlüssel die String-Payload, die Sie beim Aufruf der Benachrichtigungsfunktion definiert haben. </li></ul> Um dies besser zu verstehen, haben wir unten ein kleines Beispiel-Snippet erstellt, das Sie sich ansehen können. In diesem Beispiel senden wir eine lokale Push-Benachrichtigung mit folgendem Code: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Dadurch wird ein Timer eingestellt, um eine Benachrichtigung an das Gerät zu senden, wenn ein Tag vergangen ist. Wenn der Tag vorüber ist, wenn sich das Spiel im Hintergrund befindet oder nicht läuft, wird dem Benutzer eine Benachrichtigung mit dem angegebenen Titel und der Nachricht angezeigt (unter iOS wird der Name des Spiels angezeigt und der Titel wird ignoriert) Ein asynchrones Push-Benachrichtigungsereignis wird aufgerufen. Wenn sich das Spiel im Vordergrund befindet, wenn der Zeitpunkt für die Benachrichtigung kommt, wird es <i>nicht</i> angezeigt, aber das asynchrone Ereignis <b>wird immer noch ausgelöst</b>. In dem Fall würden Sie den Rückruf wie folgt behandeln: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Speichern / Laden</label> <input id="eleven"
type="checkbox"><div class="index_list"> Dieses Ereignis wird durch bestimmte Funktionen ausgelöst, die sich auf das Laden und Speichern von Puffern in Dateien sowie auf das Laden oder Entladen von Audio aus dem Speicher beziehen. Das Ereignis selbst enthält das eingebaute <tt>async_load</tt> DS-Karte, die mit den für die jeweilige Funktion erforderlichen Tasten aufgefüllt wird. Diese sind in den folgenden Abschnitten aufgeführt. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Puffer</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Wenn Sie die Funktionen verwenden <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> Ein asynchrones Ereignis wird ausgelöst, wenn die Datenübertragung abgeschlossen ist. Dieses Ereignis füllt die <tt>async_load</tt> Karte mit den folgenden Schlüssel / Wert-Paaren <br><br><ul><li> <b>&quot;id&quot;:</b> Die ID der asynchronen Funktion, wie sie von der verwendeten Funktion zurückgegeben wird. </li><li> <b>&quot;status&quot;:</b> wird zurückkehren <tt>true</tt> wenn die Daten korrekt gespeichert / geladen wurden, und <tt>false</tt> Andernfalls. </li></ul> Auf diese Weise können Sie den Speicher- / Ladevorgang abfragen und eine Meldung anzeigen oder Räume ändern usw., wenn der Vorgang abgeschlossen ist. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Audiogruppen</label> <input id="thirty" type="checkbox"><div class="index_list"> Wenn Sie mit <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">Audio-Gruppen arbeiten</a>, können Sie sie mit den Funktionen laden und aus dem Speicher entfernen <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> und <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Bei Verwendung der Ladefunktion wird dieses Ereignis ausgelöst, wenn der gesamte Satz der für die Gruppe festgelegten Audiodateien in den Speicher geladen wurde, und die Karte wird mit den folgenden Schlüssel / Wert-Paaren aufgefüllt: <br><br><ul><li> <b>&quot;type&quot;:</b> Dies sagt uns, welche Art von Ereignis aufgerufen wird und sein wird &quot; <tt>audiogroup_load</tt> &quot;zum Laden von Audio. </li><li> <b>&quot;group_id&quot;:</b> gibt die ID der geladenen <b>Audiogruppe zurück</b> (wie im <b>Audiogruppen-</b> <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">Editor definiert</a> ). </li></ul> Wenn alle Audiodaten für eine Gruppe geladen wurden, wird dieses Ereignis ausgelöst und kann zum Ändern von Räumen oder zum Abspielen eines Musiktitels usw. verwendet werden. </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Sozial</label> <input id="eight" type=
"checkbox"><div class="index_list"> Dieses Ereignis kann nur durch die verschiedenen spezifischen <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">sozialen Funktionen</a> ausgelöst werden und gibt ein zurück <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die unterschiedliche Schlüssel / Wert-Paare enthalten, abhängig vom Rückruf der Funktion, die das Ereignis ausgelöst hat. <br><br> Die ds_map enthält eine Reihe von Schlüsseln, von denen der wichtigste der &quot; <i>id</i> &quot; -Schlüssel ist. Dies gibt eine <b>Konstante zurück,</b> die im Code überprüft werden kann, um zu bestimmen, welche der vielen Rückrufe das Ereignis empfangen hat. Nachdem Sie diesen Schlüssel analysiert und den zurückgegebenen Wert mit den verfügbaren Konstanten verglichen haben, können Sie die restlichen Informationen aus der Karte extrahieren. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Bestenlisten und Erfolge</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Die Funktionsseiten zu <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">Social Gaming - Erfolge und Bestenlisten</a> im Abschnitt Referenz beschreiben detailliert die Funktionen und Rückrufe sowie die Konstanten, die zum Auslösen dieses Ereignisses verwendet werden, es gibt jedoch auch bestimmte Umstände, unter denen es ohne Funktionsaufruf aus dem Spiel ausgelöst wird läuft: <br><br><ul><li> wenn Ihr Spiel vom OS-Dashboard aus gestartet wird </li><li> wenn du eine Herausforderung abschließt </li><li> wenn ein anderer Spieler eine Herausforderung beendet </li><li> wenn das Spiel vom OS-Dashboard aus gestartet wird, indem Sie eine Herausforderung auswählen </li></ul><p> Jeder der oben genannten Rückrufe löst das <b>Social Event</b> und ein <tt>async_load</tt> map wird mit den folgenden Details generiert (Beachten Sie, dass es einen unterschiedlichen &quot;id&quot; -Schlüsselwert gibt, um die verschiedenen Gründe zu definieren, aus denen das Ereignis aufgerufen wurde, der Inhalt der Map jedoch alle gleich ist). <br><br></p><ul><li> &quot; <b>id</b> &quot; - Der Wert dieses Schlüssels hängt von der Art des Rückrufs ab, der das Ereignis auslöst. Es kann eine dieser Konstanten sein: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Eine Herausforderung wurde angenommen <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Eine Herausforderung wurde abgeschlossen. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Eine Herausforderung wurde vom anderen Spieler abgeschlossen. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - Das Spiel wurde mit der angegebenen Herausforderung vom OS-Dashboard aus gestartet. <br></li></ul></li><li> &quot; <b>playerid</b> &quot; - Die Spieler-ID für die Herausforderung. <br><br></li><li> &quot; <b>issuerid</b> &quot; - Die ID der Person, die die Herausforderung ausgegeben hat. <br><br></li><li> &quot; <b>state</b> &quot; - Der Status der Challenge, der einen Wert von 0 - 3 (als Zeichenfolge) für <i>ungültig</i>, <i>ausstehend</i>, <i>abgeschlossen</i> oder <i>abgelehnt hat</i>. <br><br></li><li> &quot; <b>message</b> &quot; - Die Textnachricht für die Herausforderung. <br><br></li><li> &quot; <b>issuedate</b> &quot; - Das Ausgabedatum für die Herausforderung <br><br></li><li> &quot; <b>completdate</b> &quot; - Das Fertigstellungsdatum für die Herausforderung. <br><br></li><li> &quot; <b>type</b> &quot; - Die Art der Herausforderung. Kann eine von zwei Konstanten sein: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Eine Herausforderung basierend auf dem Score-Wert. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Eine Herausforderung, die auf einer Leistung basiert. <br></li></ul></li><li> <b>„Bezeichner“</b> - Die Identifizierung String für die Herausforderung. <br><br></li><li> &quot; <b>score</b> &quot; - Die Punktzahl, die mit der Herausforderung verbunden ist. </li></ul> Nachfolgend finden Sie ein kleines Codefragment als Anwendungsbeispiel: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Einige <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">Facebook-Funktionen</a> lösen ein soziales asynchrones Ereignis aus und erstellen ein <tt>ds_map</tt> mit einigen spezifischen Informationen. Die zurückgegebenen Informationen hängen vom &quot;Typ&quot; des Ereignisses ab, das aufgerufen wurde. Sie können dies überprüfen, indem Sie den &quot;type&quot; -Schlüssel aus der ds_map lesen. Dies ist die folgende Zeichenfolge für ein Facebook-Ereignis: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Wenn das Ereignis ausgelöst wird und von diesem Typ ist, gibt es auch zusätzliche Schlüssel, die überprüft werden können: </p><ul><li> &quot; <b>requestId</b> &quot; - Der Anforderungs-ID-Wert, der vom zurückgegeben wird <tt>facebook_request_xxx_permission()</tt> Funktion, die das Ereignis ausgelöst hat <br><br></li><li> &quot; <b>result</b> &quot; - Dies wird eine der folgenden Zeichenfolgen sein: <br><br><ul><li> &quot; <b>erteilt</b> &quot; - Berechtigung (en) wurden vom Benutzer akzeptiert </li><li> &quot; <b>denied</b> &quot; - eine oder mehrere Berechtigungen wurden vom Benutzer nicht akzeptiert </li><li> &quot; <b>error</b> &quot; - ein Fehler ist aufgetreten </li></ul></li><li> <b>&quot;error</b> &quot; - Dies wird eine Beschreibung des Fehlers enthalten, ist jedoch <i>nur</i> vorhanden, wenn &quot; <b>result</b> &quot; = &quot; <b>error</b> &quot; ist. </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Dieses Ereignis kann nur durch die <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html"><span class="notranslate">Steam</span> API-</a> Funktionen ausgelöst werden und gibt ein zurück <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die unterschiedliche Schlüssel / Wert-Paare enthalten, abhängig vom Rückruf der Funktion, die das Ereignis ausgelöst hat. Die Map enthält immer den Schlüssel &quot; <b>event_type</b> &quot;, der dann analysiert werden kann, um den Typ der Funktion zu ermitteln, die das Ereignis ausgelöst hat, und den erforderlichen Code zu ändern. <br><br> Wenn Sie eine Funktion aufrufen, die dieses Ereignis auslöst, generiert sie einen eindeutigen asynchronen ID-Wert, der in einer Variablen gespeichert und als überprüft werden soll <tt>async_load</tt> map enthält immer einen ID-Schlüssel, den Sie dann analysieren können, um sicherzustellen, dass Sie auf das richtige Ereignis antworten. Die Karte enthält <i>immer</i> die folgenden Tasten, unabhängig von der <span class="notranslate">Steam</span> Funktion, mit der die asynchrone Antwort generiert wird: <br><br><ul><li> &quot; <b>id</b> &quot; - Die async-ID, die von der Funktion zurückgegeben wurde, die das Ereignis ausgelöst hat </li><li style="list-style: none"><br></li><li> &quot; <b>Ergebnis</b> &quot; - Das Ergebnis der Operation (ein realer Wert). Dies ist entweder die GML-Konstante <tt>ugc_result_success</tt> oder eine andere reelle Zahl. Sie sollten also nach dieser Konstante suchen, um sicherzustellen, dass der Anruf erfolgreich war und ob sonst etwas nicht richtig funktioniert hat. Die verbleibenden möglichen Werte werden als Ergebnis des &quot;EResult&quot; -Werts von <span class="notranslate">Steam</span> angezeigt und sollten angezeigt werden <tt>steamclientpublic.h</tt> in den SDK-Headern für alle 89 möglichen Werte. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Eine Zeichenfolge, die den Ereignistyp angibt (Details siehe unten) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Daten hochladen</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Bei Verwendung der <span class="notranslate">Steam</span> Funktionen zum Hochladen einer Bestenliste (entweder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) die zurückgegeben <tt>ds_map</tt> hat die folgenden Schlüssel / Wert-Paare: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Diese Taste enthält den Wert &quot; <b>leaderboard_upload</b> &quot;. </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot; - Dieser Schlüssel sollte mit dem ID-Wert übereinstimmen, der von der Upload- <b>Aufruffunktion</b> zurückgegeben wird </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot; - Dieser Schlüssel enthält den Namen der Bestenliste, in die geschrieben wurde </li><li style="list-style: none"><br></li><li> &quot; <b>success</b> &quot; - Wird 1 sein, wenn der Beitrag erfolgreich war, 0 ist fehlgeschlagen </li><li style="list-style: none"><br></li><li> &quot; <b>aktualisiert</b> &quot; - Wird 1 sein, wenn der Leaderboard-Score tatsächlich aktualisiert wurde (dh der neue Score war besser) oder sonst 0 </li><li style="list-style: none"><br></li><li> &quot; <b>score</b> &quot; - Dieser Schlüssel enthält die gepostete Punktzahl </li></ul> Beispiele dafür finden Sie auf den Seiten für die Score-Upload-Funktionen. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Leaderboards herunterladen</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Bei Verwendung der <span class="notranslate">Steam</span> Funktionen zum Herunterladen einer Bestenliste ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>. <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> oder <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) die zurückgegeben <tt>ds_map</tt> hat die folgenden Schlüssel / Wert-Paare: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Diese Taste enthält den Wert &quot; <b>leaderboard_download</b> &quot;. </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot; - Dieser Schlüssel muss mit dem ID-Wert übereinstimmen, der von der Funktion zum Herunterladen von Aufrufen zurückgegeben wird </li><li style="list-style: none"><br></li><li> &quot; <b>status</b> &quot; - Der Status des Rückrufs, bei dem -1 einen Fehler darstellt oder keine Ergebnisse zurückgegeben wurden und 0 einen Erfolg angibt. </li><li> &quot; <b>lb_name</b> &quot; - Dieser Schlüssel enthält den Namen der Bestenliste, in die geschrieben wurde </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot; - Die Anzahl der &quot;Zeilen&quot; der Leaderboard-Daten, die zurückgegeben werden. </li><li style="list-style: none"><br></li><li> &quot; <b>entries</b> &quot; - Eine JSON-Objektzeichenfolge, die eine weitere ds_map enthält. Diese enthält entweder den Schlüssel &quot;default&quot; (bedeutet, dass keine Ergebnisse enthalten sind) oder den Schlüssel &quot;entries&quot;, den Sie dann erhalten können. Dieser zurückgegebene Wert für &quot;Einträge&quot; ist a <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> enthält jeden Rang aus der Bestenliste, wobei jeder Eintrag in der Liste selbst auf einen anderen verweist <tt>ds_map</tt> Diese enthält die Schlüssel &quot;Name&quot;, &quot;Score&quot; und &quot;Rang&quot; und kann abhängig von der zum Hochladen verwendeten Funktion auch einen &quot;Daten&quot; -Schlüssel enthalten. </li></ul> Wir zeigen ein Beispiel für die Funktionsweise des Herunterladens von Score-Daten, indem wir die Top-10-Rangliste für das angegebene Leaderboard anfordern und die Ergebnisse im <b><span class="notranslate">Steam</span> Async-Event analysieren</b> ( <b>Informationen</b> zum Hochladen von Beispielen finden Sie auf den entsprechenden Funktionsseiten). Zu Beginn müssen wir die Ergebnisse mit folgendem Code anfordern: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Dies sendet eine Anfrage an den <span class="notranslate">Steam</span> Server für die Ergebnisse der Bestenliste &quot;Game Scores&quot;, wobei die <b>asynchrone ID</b> der Anfrage in der Variablen &quot;score_get&quot; gespeichert wird. Dies wird dann im <b><span class="notranslate">Steam</span> Async Event</b> folgendermaßen behandelt: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Was wir hier tun, ist zuerst den &quot;id&quot; -Schlüssel des Specials zu überprüfen <tt>async_load</tt> Karte. Wenn dieser Wert mit dem Wert der ursprünglichen Rückruffunktion (in der Variablen &quot;score_get&quot; gespeichert) übereinstimmt, werden die Daten dann weiter verarbeitet. Das erste, was wir tun, ist das zu analysieren <tt>async_load</tt> ds_map für den Schlüssel &quot;entry&quot;, der ein JSON-Objekt enthält, das die Leaderboard-Daten enthält. Dieses JSON-Objekt wird dann decodiert (siehe <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) als eine andere ds_map, und diese neue Karten-ID wird in der Variablen &quot;map&quot; gespeichert. <br><br> Diese Map wird auf den Schlüssel &quot;default&quot; geprüft. Wenn dies gefunden wird, wird die Map zerstört und das Ereignis beendet. Wenn keine &quot;Standard&quot; -Taste gefunden wird, analysiert der Code die Karte, um die erforderlichen Informationen über die Bestenliste zu extrahieren. Dazu wird zunächst eine ds_list aus der &quot;entry&quot; -Taste der ds_map extrahiert und anschließend jeder Eintrag der Liste durchlaufen Holen Sie sich eine <i>weitere</i> ds_map mit Namen, Score und Rang jedes Eintrags. Diese Werte werden dann in Arrays gespeichert und dann überprüft, ob ein zusätzlicher &quot;Daten&quot; -Schlüssel vorhanden ist. Wenn dies der Fall ist (dh die Partitur wurde mit einem zusätzlichen Datenpaket hochgeladen), wird das auch analysiert und zum Debuggen an die Compilerkonsole gesendet, bevor der Puffer zerstört und die Karte anschließend zerstört wird. Wenn der &quot;data&quot; -Schlüssel enthalten ist, muss er mit dem dekodiert werden <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> bevor es richtig gelesen werden kann. <br><br> Sobald die Schleife beendet ist, wird die Liste der Einträge sowie die Karte, aus der sie entnommen wurden, gelöscht. Es besteht keine Notwendigkeit, das zu zerstören <tt>async_load</tt> ds_map, da dies von <i><span class="notranslate">GameMaker Studio 2</span></i> für Sie erledigt wird. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Herunterladen von UGC (Benutzergenerierter Inhalt)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Wenn Sie die <span class="notranslate">Steam</span> Funktionen zum Herunterladen von <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">User Generated Content (UGC) verwenden</a>, wird eine Reihe von Funktionen dieses Ereignis auslösen. Jede Funktion generiert jedoch eine <tt>async_load</tt> ds_map mit unterschiedlichen Schlüssel / Wert-Paaren (obwohl sie immer die allgemeinen Schlüssel &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; und &quot; <b>event_type</b> &quot; enthalten), sehen Sie sich daher bitte die spezifische Seite für die verwendete Funktion für Details und Beispiele an. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Einzigartige UGC-Ereignisse</label> <input id="twentysix" type="checkbox"><div class="index_list"> Das <span class="notranslate">Steam</span> Async-Ereignis kann auch ausgelöst werden, wenn ein Benutzer einen Artikel außerhalb des Spiels abonniert. Zum Beispiel wechselt er zu einem Browser, abonniert einen neuen Artikel und wechselt dann wieder zum Spiel. In diesen Fällen ist das <tt>async_load</tt> Die Karte enthält <b>nur</b> die folgenden Details (und keine der Standardwerte, die oben auf dieser Seite aufgeführt sind): <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>Published_file_id</b> &quot; - die ID des neu installierten UGC-Elements (Sie können die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> um den Pfad zu dem installierten Objekt zu erhalten) </li><li style="list-style: none"><br></li></ul> Das <span class="notranslate">Steam</span> Async-Ereignis kann auch ausgelöst werden, wenn ein Workshop-Artikel abonniert wird - entweder innerhalb der App oder extern von einem Workshop-Browser - und in diesen Fällen der <tt>async_load</tt> Die Karte enthält die folgenden Schlüssel / Wert-Paare: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>Published_file_id</b> &quot;: Dieser Schlüssel hat die veröffentlichte Datei-ID des neu abonnierten Elements </li><li style="list-style: none"><br></li></ul> Das Ereignis wird ausgelöst, wenn ein Element auch nicht abonniert ist. Die DS-Karte enthält Folgendes: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Dieser Schlüssel enthält den Wert &quot; <b>ugc_item_unsubscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>Published_file_id</b> &quot;: Dieser Schlüssel hat die veröffentlichte Datei-ID des nicht abonnierten Elements </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">System</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Dieses Ereignis kann nur durch ein Ereignis auf Systemebene (z. B. Erkennung eines Gamepads oder automatische Anmeldung bei XBox Live) ausgelöst werden, und es wird ein Ereignis zurückgegeben <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> in der Variablen gespeichert <tt>async_load</tt>, die unterschiedliche Schlüssel / Wert-Paare enthalten, abhängig von dem Ereignis auf Systemebene, das den Rückruf ausgelöst hat. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Spielpads</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Wenn dieses Ereignis für ein Gamepad ausgelöst wird, das verbunden oder getrennt wird, wird eines der folgenden Schlüssel / Wert-Paare im zurückgegeben <tt>async_load</tt> Karte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - der Typ des empfangenen Systemereignisses, bei dem es sich um eine der folgenden Zeichenfolgen handelt: <br><br><ul><li> &quot; <b>Gamepad entdeckt</b> &quot; - passiert, wenn das System meldet, dass ein neues Gamepad angeschlossen wurde </li><li> &quot; <b>Gamepad verloren</b> &quot; - passiert, wenn das System die Verbindung zu einem Gamepad verloren hat </li></ul></li><li> &quot; <b>pad_index</b> &quot; - der Index des hinzugefügten oder entfernten Pads </li></ul><p> Mit diesem Ereignis können Sie jetzt Ihre gesamte Gamepad-Überprüfungslogik vom Schritt- oder Alarmereignis in das Systemereignis verschieben und nur ausführen, wenn es tatsächlich erforderlich ist. </p></div><br><a name="async_system_gamepads" id="async_system_gamepads"></a> <label class="collapse" for="thirtythree">Virtuelle Tastaturen</label> <input id="thirtythree" type="checkbox"><div class="index_list"><p> Wenn dieses Ereignis ausgelöst wird, wenn eine virtuelle Tastatur geöffnet oder geschlossen wird, werden die folgenden Schlüssel / Wert-Paare in der Tastatur zurückgegeben <tt>async_load</tt> Karte: <br><br></p><ul><li> &quot; <b>event_type</b> &quot; - der Typ des empfangenen Systemereignisses, der für <b>virtuelle Tastaturen</b> &quot; <b>Status der</b> virtuellen Tastatur&quot; ist. </li><li style="list-style: none"><br></li><li> &quot; <b>screen_height</b> &quot; - die Höhe der virtuellen Tastatur (in Pixel). Dies ist 0, wenn die Tastatur unsichtbar ist. </li><li style="list-style: none"><br></li><li> &quot; <b>keyboard_status</b> &quot; - der aktuelle Status der Tastatur, der als eine der folgenden Zeichenfolgen zurückgegeben wird: <br><br><ul><li> &quot;verstecken&quot; </li><li> &quot;versteckt&quot; </li><li> &quot;zeigen&quot; </li><li> &quot;sichtbar&quot; </li></ul></li></ul><p> Sehen Sie <a href=
"../../../3_scripting/4_gml_reference/controls/virtual%20keys/index.html">hier</a> für weitere Informationen über die virtuelle Tastatur. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">XBox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> Das asynchrone Systemereignis kann ausgelöst werden, wenn Sie die <b><span class="notranslate">XBox One</span></b> mithilfe des <b>UWP-</b> Exports anvisieren und die Option <b>XBox Live</b> aktivieren in den <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">UWP-Spieloptionen aktivieren</a>. Wenn Sie ein UWP-Projekt von <i><span class="notranslate">GameMaker Studio 2</span></i> starten, bei dem Xbox Live aktiviert ist, versucht das Projekt automatisch, sich automatisch bei Xbox Live anzumelden. Die Ergebnisse dieses Anmeldeversuchs werden als eines der folgenden Schlüssel / Wert-Paare im zurückgegeben <tt>async_load</tt> Karte: </p><ul><li> &quot; <b>event_type</b> &quot; - der Typ des empfangenen Systemereignisses, bei dem es sich um eine der folgenden Zeichenfolgen handelt: <br><br><ul><li> &quot; <b>Benutzer angemeldet</b> &quot; - die unbeaufsichtigte Benutzeranmeldung wurde erfolgreich abgeschlossen </li><li> &quot; <b>Benutzeranmeldung fehlgeschlagen</b> &quot; - Die unbeaufsichtigte Benutzeranmeldung ist fehlgeschlagen (in diesem Fall können Sie die Funktion verwenden <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> um den Benutzer zu veranlassen, ein Konto für die Anmeldung auszuwählen) </li><li> &quot; <b>Benutzer abgemeldet</b> &quot; - der Benutzer hat sich abgemeldet </li></ul></li></ul><p> Weitere Informationen zu den spezifischen Funktionen von XBox Live finden Sie <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">hier</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="../objects.html">Der Objekteditor</a> </div><div style="float:right"> Weiter: <a href="draw_events.html">Ereignisse zeichnen</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
