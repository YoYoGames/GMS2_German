<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Language Features</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/3_scripting/3_gml_overview/14_language_features.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Sprachmerkmale </h2><div class="body-scroll"><p><br></p><p> Die <span class="notranslate">GameMaker</span> Sprache (GML) hat eine Reihe von Funktionen, die Teil der wesentlichen Struktur des gesamten mit der Sprache geschriebenen Codes sind. Jedes dieser Elemente wird in jedem Code verwendet, den Sie mehrmals schreiben. Sie sollten also wissen, was sie sind und wie sie funktionieren, bevor Sie mit der Programmierung eines Projekts beginnen. </p><blockquote> <label class="collapse" for="one">Wenn / Bedingter Operator</label> <input id="one" type="checkbox"><div class="index_list"> Eine einfache &quot;if&quot; -Anweisung hat folgende Form: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> oder es kann die etwas komplexere Form &quot;if... else...&quot; haben: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt; else
&lt;statement&gt;<span class="notranslate"></span></p><br> In diesem Fall wird der Ausdruck ausgewertet, und wenn der (gerundete) Wert &lt;= 0 ist ( <tt>false</tt> ) die Anweisung nach else wird ausgeführt, ansonsten ( <tt>true</tt> ) Die andere Anweisung wird ausgeführt. Es ist eine gute Angewohnheit, immer geschweifte Klammern um die Anweisungen im if zu setzen, und für jede Anweisung eine neue Zeile im Block zu nehmen, damit der Endcode diese Form hat: <br><br><p class="code">if (&lt;expression&gt;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Als kleines Beispiel betrachten Sie den folgenden Code, der die Instanz auf die Position x = 200 im Raum verschiebt: <br><br><p class="code">if (x &lt; 200)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Beachten Sie, dass Sie auch <i>zusammengesetzte</i> Überprüfungen in einem if durchführen können, dh: Überprüfen Sie verschiedene Werte oder Ausdrücke in derselben Anweisung. Wenn Sie dies tun, wird <i><span class="notranslate">GameMaker Studio 2</span></i> jeden einzelnen nach dem anderen bewerten, und wenn einer von ihnen den Wert false ergibt, wird der Rest übersprungen. Beispielsweise: <br><br><p class="code">if (keyboard_check_pressed(vk_enter) &amp;&amp;
!instance_exists(obj_Player))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;go = false<br>
&nbsp;&nbsp;&nbsp;alarm[0] = room_speed<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Sie können auch <b>bedingte Operationen</b> (auch als <b>ternäre</b> Operationen bezeichnet) ausführen, was im Wesentlichen eine &quot;Abkürzung&quot; für die Ausführung eines grundlegenden &quot;wenn&quot; ist. Es hat die folgende Syntax: <br><br><p class="code">variable = condition ? &lt;expression1 (if
<i>true</i>)&gt; : &lt;expression2 (if <i>false</i>)&gt;<span class="notranslate"></span></p><br> Der bedingte Operator gibt einen von zwei gegebenen Werten zurück, abhängig davon, ob die Bedingung ausgewertet wird <tt>true</tt> oder <tt>false</tt>, beispielsweise: <br><br><p class="code">var temp_x = x &lt; (room_width / 2) ? 32:
room_width - 32;<span class="notranslate"></span></p><br> Der obige Code überprüft den Wert von &quot;x&quot; gegen den Wert der halben Raumbreite und wenn er dann kleiner ist, wird &quot;temp_x&quot; auf 32 gesetzt, ansonsten &quot;temp_x&quot; wird room_width - 32 sein. Hier sind ein paar weitere Beispiele von benutzen: <br><br><p class="code">draw_text(x, y, "The fee is " + (global.Member ?
"$2.00" : "$10.00"));<br>
path_start((global.level &gt; 10 ? path_hard : path_easy;), 2,
path_action_reverse, true);<br>
--hp &lt;= 0 ? instance_destroy() : score += 10;<span class="notranslate"></span></p><br> Es ist erwähnenswert, dass Sie bedingte Operationen verschachteln können, aber wenn Sie dies tun, dann muss jede Operation in Klammern eingeschlossen sein, zum Beispiel: <br><br><p class="code">var c = a ? "foo" : (b ? "bar" : "wii"); //
Correct<br>
var c = a ? "foo" : b ? "bar" : "wii";&nbsp;&nbsp; // Will cause an
error<span class="notranslate"></span></p></div><br> <label class="collapse" for="two">wiederholen</label> <input id="two"
type="checkbox"><div class="index_list"> Eine &quot;Wiederholungs&quot; -Anweisung hat die Form <br><br><p class="code">repeat (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> Die Anweisung wird so oft wiederholt, wie der gerundete Wert des Ausdrucks angibt. Das folgende Programm erstellt beispielsweise fünf Bälle an zufälligen Positionen. <br><br><p class="code">{<br>
repeat (5) instance_create_layer(random(400), random(400),
"Instances", obj_ball);<br>
}<br><span class="notranslate"></span></p><p><br> Dies kann sehr nützlich sein, um ein mehrfaches Eintippen des gleichen Codes oder die Verwendung von Arrays oder das Zählen mehrerer Operationen usw. zu vermeiden. Zum Beispiel: <br><br></p><p class="code">{<br>
var i, total;<br>
i = 0;<br>
total = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;total += array[i];<br>
&nbsp;&nbsp;&nbsp;i += 1<br>
&nbsp;&nbsp;&nbsp;}<br>
draw_text(32, 32, total);<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="three">während</label> <input id="three"
type="checkbox"><div class="index_list"> Eine &quot;while&quot; -Anweisung hat die Form <br><br><p class="code">while (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> Solange der Ausdruck wahr ist, wird die Anweisung (die auch ein Codeblock sein kann) ausgeführt. <b>Sei vorsichtig mit deinen While-Loops!</b> Sie können ganz einfach unendliche Loops erstellen. In diesem Fall hängt Ihr Spiel und reagiert nicht mehr auf Benutzereingaben. Im Folgenden finden Sie ein Beispiel für eine typische Art der Verwendung von &quot;while&quot;: <br><br><p class="code">{<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Das obige Programm versucht, das aktuelle Objekt an eine freie Position zu bringen (dies ist ungefähr dasselbe wie die Aktion, um ein Objekt an eine zufällige Position zu bewegen). </div><br> <label class="collapse" for="four">machen bis</label> <input id=
"four" type="checkbox"><div class="index_list"> Ein &quot;do&quot; ist wirklich die &quot;tu... bis&quot; Aussage, da man ohne die andere keine haben kann. Es hat diese Form: <br><br><p class="code">do &lt;statement&gt; until (&lt;expression&gt;)<span class="notranslate"></span></p><br> Die Anweisung (die auch ein Codeblock sein kann) wird ausgeführt, bis der Ausdruck als wahr gefunden wird, und die ursprüngliche Anweisung wird immer mindestens einmal ausgeführt. Sei vorsichtig mit deinen do-Schleifen, da du sie leicht für immer in Schleife machen kannst. In diesem Fall hängt dein Spiel und reagiert nicht mehr auf Benutzereingaben. Im Folgenden finden Sie ein Beispiel für einen typischen Weg, &quot;do... bis&quot; zu verwenden: <br><br><p class="code">{<br>
do<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
until (place_free(x, y)); }<br><span class="notranslate"></span></p><br> Das obige Programm versucht, das aktuelle Objekt an eine freie Position zu bringen (dies ist ungefähr dasselbe wie die Aktion, um ein Objekt an eine zufällige Position zu bewegen). </div><br> <label class="collapse" for="five">zum</label> <input id="five"
type="checkbox"><div class="index_list"> Eine &quot;for&quot; -Anweisung hat diese Form: <br><br><p class="code">for (&lt;statement1&gt; ; &lt;expression&gt;
;&lt;statement2&gt;) &lt;statement3&gt;<span class="notranslate"></span></p><br> Dies funktioniert folgendermaßen: First statement1 wird ausgeführt, dann wird der Ausdruck ausgewertet und, falls er wahr ist, wird die Anweisung 3 ausgeführt. Dann wird Anweisung 2 und dann der Ausdruck erneut ausgewertet. Diese Schleife wird fortgesetzt, bis der Ausdruck als falsch erkannt wird. <br><br> Nun, das hört sich kompliziert an, wenn Sie so geschrieben werden, aber Sie sollten es wie folgt interpretieren: <br><br><ul><li> Die erste Anweisung initialisiert die for-Schleife. </li><li> Der Ausdruck testet, ob die Schleife beendet werden soll. </li><li> Statement2 ist die &quot;step&quot; -Anweisung, die zur nächsten Schleifenauswertung geht. </li></ul> Dies ist äußerst nützlich für wiederkehrende Aufgaben, bei denen mehrere Codezeilen auf andere Weise verwendet werden, und wird häufig als Zähler zum Auswerten von Arrays oder Zeichnen von Objekten verwendet. Das folgende Codebeispiel veranschaulicht eine typische Verwendung für diese Art von Anweisung: <br><br><p class="code">{<br>
for (var i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;draw_text(32, 32 + (i * 32), string(i) + ". "+
string(scr[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code initialisiert eine for-Schleife, beginnend bei 0 und aufwärts bis 9, und verwendet dann den Schleifenwert von &quot;i&quot;, um die in einem Array gespeicherten Werte auf dem Bildschirm zu zeichnen. Beachten Sie, wie die &quot;for&quot; -Schleifenvariable &quot;i&quot; verwendet wird, um nicht nur das Array zu durchlaufen, sondern auch eine Zahl zu zeichnen und <i><span class="notranslate">GameMaker Studio 2</span></i> mitzuteilen, wohin die Werte im Raum gezeichnet werden sollen. Diese Flexibilität ist einer der Hauptgründe, warum &quot;for&quot; -Schleifen beim Programmieren so wichtig sind. </div><br> <label class="collapse" for="six">Schalter</label> <input id="six"
type="checkbox"><div class="index_list"> In einer Reihe von Situationen möchten Sie, dass Ihre Instanzen abhängig von einem bestimmten Wert eine Aktion abschließen. Sie können dies mit einer Anzahl von aufeinander folgenden &quot; <tt>if</tt> &quot;Anweisungen, aber wenn die möglichen Entscheidungen über zwei oder drei sind, ist es normalerweise einfacher, die&quot; switch &quot;-Anweisung zu verwenden. Eine switch-Anweisung hat die folgende Form: <br><br><p class="code">switch (&lt;expression&gt;)<br>
{<br>
case &lt;expression1&gt;: &lt;statement1&gt;; ... ; break;<br>
case &lt;expression2&gt;: &lt;statement2&gt;; ... ; break;<br>
...<br>
default: &lt;statement&gt;;<br>
}<br><span class="notranslate"></span></p><br> Dies funktioniert wie folgt: <br><br><ul><li> Zuerst wird der Ausdruck ausgeführt. </li><li> Als nächstes wird es mit den Ergebnissen der verschiedenen Ausdrücke nach jeder der Fallanweisungen verglichen. </li><li> Die Ausführung wird nach der ersten case-Anweisung mit dem korrekten Wert fortgesetzt, <i>bis eine break-Anweisung gefunden wird</i>. </li><li> Wenn keine case-Anweisung den richtigen Wert hat, wird die Ausführung nach der Standardanweisung fortgesetzt (es ist keine Standardanweisung erforderlich, in diesem Fall wird keine Aktion ausgeführt). </li></ul> Beachten Sie, dass mehrere Case-Anweisungen für dieselbe Anweisung platziert werden können. Außerdem ist die Unterbrechung nicht erforderlich, und wenn keine break-Anweisung vorhanden ist, wird die Ausführung einfach mit dem Code für die nächste case-Anweisung fortgesetzt. Dies bedeutet, dass Sie einen Hierarchie- &quot;Schalter&quot; erstellen können, in dem je nach Eingabewert verschiedene Code-Abschnitte ausgeführt werden. Hier ist ein Beispiel für einen typischen &quot;Switch&quot; aus einem Spiel: <br><br><p class="code">{<br>
switch (keyboard_key)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;case vk_left:<br>
&nbsp;&nbsp;&nbsp;case ord("A"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_right:<br>
&nbsp;&nbsp;&nbsp;case ord("D"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_up:<br>
&nbsp;&nbsp;&nbsp;case ord("W"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_down:<br>
&nbsp;&nbsp;&nbsp;case ord("S"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code verwendet &quot;switch&quot;, um nach einem Tastaturereignis zu suchen, und vergleicht das dann mit den aufgelisteten Fällen. Wenn es einen der erforderlichen Werte erfüllt, wird der entsprechende Code ausgeführt. Beachten Sie, wie in dem Code, den wir verwendet haben, die Art und Weise, wie &quot;wechseln&quot; mehrere Fälle überprüfen kann und fortfahren kann, wenn keine Unterbrechung auftritt, um zu ermöglichen, dass verschiedene Schlüssel verwendet werden, um das gleiche Ergebnis zu erhalten. Dies ist nur eine der Möglichkeiten, wie Sie mehrere Konfigurationen für die Bewegung in Ihren Spielen zulassen können. </div><br> <label class="collapse" for="seven">Unterbrechung</label> <input id="seven"
type="checkbox"><div class="index_list"> Die Anweisung &quot;break&quot; wird verwendet, um vorzeitig zu beenden <tt>for</tt>, <tt>repeat</tt>, <tt>while</tt>, <tt>do... until</tt> Schleife irgendeiner Art, oder um a zu erzählen <tt>switch</tt> Anweisung, um an diesem Punkt zu enden, oder um a vorzeitig zu beenden <tt>with</tt> Anruf. Im Folgenden finden Sie einige Beispiele, wie dies verwendet werden kann. Die Syntax lautet einfach: <br><br><p class="code">break;<span class="notranslate"></span></p><br><p> &quot;Pause&quot; in einem <tt>for</tt> Schleife: <br><br></p><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = 234 break;<br>
&nbsp;&nbsp;&nbsp;}<br>
num = i;<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; in einem <tt>repeat</tt> Schleife: <br><br><p class="code">{<br>
var i, temp;<br>
i = 0;<br>
temp = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;temp += array[i];<br>
&nbsp;&nbsp;&nbsp;if temp &gt; max_total break else i += 1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; in einem <tt>while</tt> Schleife: <br><br><p class="code">{<br>
var i;<br>
i = 0;<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;if i &gt; 50 break else i+=1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; bei der Verwendung <tt>with</tt>: <br><br><p class="code">{<br>
var count = 0;<br>
with (obj_Enemy)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;count++;<br>
&nbsp;&nbsp;&nbsp;if count &gt; 10 break;<br>
&nbsp;&nbsp;&nbsp;hp = 100;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="eight">fortsetzen</label> <input id=
"eight" type="checkbox"><div class="index_list"> Die Continue-Anweisung hat folgende Form: <br><br><p class="code">continue<span class="notranslate"></span></p><br> Wird innerhalb einer Anweisung verwendet, die eine Schleife bildet ( <tt>repeat</tt>, <tt>while</tt>, <tt>do... until</tt> oder <tt>for</tt> ), wird es sofort zum Anfang der Schleife zurückspringen, als ob die Schleife durchlaufen und zurückgeschleift worden wäre (wenn sie außerhalb einer Schleife benutzt wird, fungiert sie als eine <tt>exit</tt> Anweisung, Beenden der Veranstaltung). Es wird auch dasselbe tun, wenn Sie das benutzen <tt>with</tt> Funktion, bei der der Code zur nächsten Instanz springt und erneut ausgeführt wird. <br><br> Im Folgenden finden Sie ein Beispiel für die Verwendung in einer &quot;for&quot; -Schleife: <br><br><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = "" continue;<br>
&nbsp;&nbsp;&nbsp;array[i] = "";<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code springt zurück zum Anfang der Schleife, wenn der Array [i] -Wert bereits eine leere Zeichenfolge ist. </div><br> <label class="collapse" for="eleven">Ausfahrt</label> <input id=
"eleven" type="checkbox"><div class="index_list"> Die Exit-Anweisung hat die Form: <br><br><p class="code">exit;<span class="notranslate"></span></p><br> &quot;Beenden&quot; beendet einfach die Ausführung des aktuellen Skripts oder Ereignisses. Beachten Sie, dass hier je nach Umfang ein leichter Unterschied besteht: wenn Sie verwenden <tt>exit</tt> In einem Skript wird das Skript einfach beendet und zu dem Code zurückgeleitet, der das Skript aufgerufen hat. Wenn Sie dieses Ereignis jedoch innerhalb eines Objekts in einem Codeblock verwenden, wird <i>das gesamte Ereignis beendet,</i> auch wenn nach dem <i>Ereignis</i> mehrere separate Codeblöcke vorhanden sind Funktion wurde aufgerufen. In der Regel wird es verwendet, um eine Instanz zu vermeiden, in der ein bestimmter Codeblock ausgeführt wird, beispielsweise ein Kollisionsereignis. Der folgende Code gibt ein einfaches Beispiel dafür: <br><br><p class="code">{<br>
if !visible exit;<br>
while (place_meeting(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= lengthdir_x(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;y -= lengthdir_y(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code prüft eine Variable und wenn sie in true aufgelöst wird, dann existiert der Codeblock, andernfalls wird der Rest des Codes ausgeführt. <div class="note"> <b>Hinweis:</b> Es endet nicht die Ausführung des Spiels. Dazu müssen Sie die Funktion verwenden <a href=
"../4_gml_reference/game/game_end.html"><tt>game_end</tt></a>. </div></div><br> <label class="collapse" for="nine">mit</label> <input id="nine"
type="checkbox"><div class="index_list"> Wie im Abschnitt <a hreff=
"7_Addressing_Variables.html">Adressierung von Variablen in anderen Instanzen angegeben</a>, ist es möglich, den Wert von Variablen in anderen Instanzen zu lesen und zu ändern. Aber in einer Reihe von Fällen möchten Sie viel mehr tun als nur eine einzelne Variable mit diesen anderen Instanzen zu ändern. Stellen Sie sich zum Beispiel vor, dass Sie alle Ballobjekte in Ihrem Spiel um 8 Pixel verschieben möchten. Sie können denken, dass dies einfach durch den folgenden Code erreicht wird: <br><br><p class="code">obj_ball.y = obj_ball.y + 8;<span class="notranslate"></span></p><br> Dies ist jedoch nicht korrekt, da die rechte Seite der Zuweisung den Wert der y-Koordinate des ersten Balls erhält und 8 dazu addiert. Als nächstes wird dieser neue Wert als y-Koordinate aller Bälle gesetzt. Das Ergebnis ist, dass alle Bälle die gleiche y-Koordinate erhalten, und selbst wenn Sie Folgendes verwenden: <br><br><p class="code">obj_ball.y += 8;<span class="notranslate"></span></p><br> es wird genau die gleiche Wirkung haben, weil es einfach eine Abkürzung der ersten Aussage ist. So wie erreichen wir das? Zu diesem Zweck existiert die <b>with-</b> Anweisung in GML. Seine globale Form ist: <br><br><p class="code">with (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> &lt;Ausdruck&gt; gibt eine oder mehrere Instanzen an, und dazu können Sie eine Instanz-ID, den Namen eines Objekts (das angibt, dass <i>alle Instanzen</i> dieses Objekts den Codeblock ausführen) oder eines der speziellen <i>Schlüsselwörter</i> ( <b>alle</b>, <b>selbst</b>, <b>andere</b> ). &lt;Statement&gt; wird jetzt für jede der angegebenen Instanzen ausgeführt, als ob diese Instanz die aktuelle (Selbst-) Instanz ist. Um alle Instanzen des Ballobjekts um 8 Pixel nach unten zu verschieben, können Sie Folgendes eingeben: <br><br><p class="code">with (obj_ball) y += 8;<span class="notranslate"></span></p><br> Wenn Sie mehrere Anweisungen ausführen möchten, setzen Sie geschweifte Klammern um sie herum, genau wie bei jedem anderen Programm. Um beispielsweise alle Bälle in eine zufällige Position zu bewegen, können Sie Folgendes verwenden: <br><br><p class="code">with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Beachten Sie, dass die angegebene Instanz innerhalb der Anweisung (en) zur Ziel (selbst) -Instanz geworden ist, die den Codeblock ausführt, was bedeutet, dass die Anweisungen der ursprünglichen Instanz (die das &quot;mit&quot; und den Codeblock enthält) zu <b>andere</b> Instanz. Um beispielsweise alle Bälle an die Position der aktuellen Instanz zu verschieben, können Sie Folgendes eingeben: <br><br><p class="code">with (obj_ball) { x = other.x; y = other.y; }<span class="notranslate"></span></p><br> Die With-Anweisung ist ein extrem mächtiges Werkzeug und ist in vielen, vielen Situationen nützlich. Daher ist es wichtig, dass Sie vollständig verstehen, wie es verwendet werden kann. Um zu helfen, gibt es ein paar weitere Anwendungsbeispiele unten: <br><br><p class="code">with (instance_create_layer(x, y, "Instances",
obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;speed = other.speed;<br>
&nbsp;&nbsp;&nbsp;direction = other.direction;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Der obige Code erstellt eine Instanz von obj_Ball und weist ihm die Geschwindigkeit und Richtung der Instanz zu, die den gesamten Codeblock ausführt. <br><br><p class="code">with (instance_nearest(x, y, obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;instance_destroy();<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Der obige Code zerstört die Instanz von obj_Ball, die der Instanz am nächsten liegt, die den Code ausführt. <br><br><p class="code">var inst;<br>
inst = noone;<br>
with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if str &gt; other.str inst = id;<br>
&nbsp;&nbsp;&nbsp;}<br>
if inst != noone target = inst;<br><span class="notranslate"></span></p><br> Der obige Code ist etwas komplexer als die vorherigen, da er eine lokale Variable verwendet. Diese Variable ist lokal für das <i>Skript</i> und nicht für die Instanz und kann daher von allen Instanzen verwendet und aufgerufen werden, auf die im Codeblock verwiesen wird. Also haben wir es im Code auf das spezielle <i>Schlüsselwort</i> <b>noone gesetzt</b> und verwenden dann die &quot;mit&quot; -Konstruktion, um jede Instanz von obj_Ball ihre &quot;str&quot; ​​-Variable gegen die der Instanz, die den Codeblock ausführt, zu überprüfen. Wenn der Wert der Variablen größer ist, speichern sie ihre eindeutige ID in der lokalen Variable &quot;inst&quot;, was bedeutet, dass am Ende des Codes nur die Instanz mit einem Wert größer als die aufrufende Instanz (oder das <i>Schlüsselwort</i> <b>noone,</b> wenn keine vorhanden ist) größer sind) werden in der lokalen Variable inst gespeichert. Weitere Informationen zu lokalen Variablen finden Sie im Abschnitt <a href="6_scope.html">Variablen und Variablenbereich</a>. </div><br> <label class="collapse" for="ten">Rückkehr</label> <input id="ten"
type="checkbox"><div class="index_list"> Die Rückgabeanweisung hat die Form: <br><br><p class="code">return (&lt;expression&gt;)<br><span class="notranslate"></span></p><br> Sie benutzen nur die <tt>return</tt> Anweisung in <a href=
"../../2_interface/1_editors/scripts.html">Skripten</a>, und es wird verwendet, um einen Wert aus dem Skript zurückzugeben, der in weiteren Code- oder Skriptaufrufen verwendet werden soll. Es sollte beachtet werden, dass die <i>Ausführung des Skripts bei der return-Anweisung endet</i>, was bedeutet, dass jeder Code, der nach dem Aufruf der Rückgabe kommt, nicht ausgeführt wird. Hier ist ein kurzes Beispielskript namens &quot; <tt>scr_sqr</tt> &quot;Das berechnet das Quadrat von welchem ​​Wert auch immer an es übergeben wird, und es enthält Fehlerfang für den Fall, dass das Argument, dass es übergeben wird, keine reelle Zahl ist: <br><br><p class="code">{<br>
if !is_real(argument0)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return 0;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return (argument0 * argument0);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Um ein Skript aus einem Codeabschnitt heraus aufzurufen, gehen Sie genauso vor wie beim Aufrufen von Funktionen - schreiben Sie den Skriptnamen mit den Argumentwerten in Klammern. Also würde das obige Skript so heißen: <br><br><p class="code">if keyboard_check_pressed(vk_enter)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;val = scr_sqr(amount);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="index.html">GML-Übersicht</a> </div><div style="float:right"> Weiter: <a href="1_code.html">Grundlegende Code-Struktur</a> </div></div></div><h5> © Urheberrecht <span class="notranslate">YoYo Games Ltd.</span> 2017 Alle Rechte vorbehalten </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
