<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Language Features</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/3_scripting/3_gml_overview/14_language_features.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F3_scripting%2F3_gml_overview%2F14_language_features.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Sprachmerkmale </h2><div class="body-scroll"><p><br></p><p> Die <span class="notranslate">GameMaker</span> Sprache (GML) verfügt über eine Reihe von Funktionen, die zur wesentlichen Struktur des gesamten mit der Sprache geschriebenen Codes gehören. Jede davon wird in jedem Code verwendet, den Sie mehrmals schreiben. Sie sollten daher wissen, was sie sind und wie sie funktionieren, bevor Sie mit der Programmierung eines Projekts beginnen. </p><blockquote> <label class="collapse" for="one"><span class=
"notranslate">if</span> / Bedingter Operator</label> <input id=
"one" type="checkbox"><div class="index_list"> Eine einfache <tt>"if"</tt> Die Anweisung hat folgende Form: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> oder es kann etwas komplexer sein <tt>"if... else..."</tt> bilden: <br><br><p class="code">if (&lt;expression&gt;) &lt;statement&gt; else
&lt;statement&gt;<span class="notranslate"></span></p><br> In diesem Fall wird der Ausdruck ausgewertet und wenn der (gerundete) Wert &lt;= 0 ist ( <tt>false</tt> ) Die Anweisung after else wird ausgeführt, andernfalls ( <tt>true</tt> ) Die andere Anweisung wird ausgeführt. Es ist eine gute Angewohnheit, die Anweisungen im if immer mit geschweiften Klammern zu versehen und für jede Anweisung eine neue Zeile im Block zu verwenden. Der End-Code hat also die folgende Form: <br><br><p class="code">if (&lt;expression&gt;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&lt;statement&gt;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Als kleines Beispiel betrachten Sie den folgenden Code, der die Instanz zur Position x = 200 im Raum bewegt: <br><br><p class="code">if (x &lt; 200)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Beachten Sie, dass Sie auch <i>Compound-</i> Checks in einem if durchführen können, dh: Überprüfen Sie verschiedene Werte oder Ausdrücke in derselben Anweisung. Wenn Sie dies tun, wertet <i><span class="notranslate">GameMaker Studio 2</span></i> jeden von ihnen einzeln aus. Wenn einer von ihnen als falsch ausgewertet wird, wird der Rest übersprungen. Zum Beispiel: <br><br><p class="code">if (keyboard_check_pressed(vk_enter) &amp;&amp;
!instance_exists(obj_Player))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;go = false<br>
&nbsp;&nbsp;&nbsp;alarm[0] = room_speed<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Sie können auch <b>bedingte Operationen</b> (auch als <b>ternäre</b> Operationen bezeichnet) ausführen. <b>Dies</b> ist im Wesentlichen eine &quot;Abkürzung&quot; für die Ausführung eines einfachen &quot;if&quot;. Es hat die folgende Syntax: <br><br><p class="code">variable = condition ? &lt;expression1 (if
<i>true</i>)&gt; : &lt;expression2 (if <i>false</i>)&gt;<span class="notranslate"></span></p><br> Der Bedingungsoperator gibt einen von zwei angegebenen Werten zurück, je nachdem, ob die Bedingung ausgewertet wird <tt>true</tt> oder <tt>false</tt>, zum Beispiel: <br><br><p class="code">var temp_x = x &lt; (room_width / 2) ? 32:
room_width - 32;<span class="notranslate"></span></p><br> Der obige Code prüft den Wert von &quot;x&quot; gegen den Wert der halben Raumbreite. Wenn er kleiner ist, wird &quot;temp_x&quot; auf 32 gesetzt. Andernfalls wird &quot;temp_x&quot; room_width - 32 sein. Hier einige Beispiele benutzen: <br><br><p class="code">draw_text(x, y, "The fee is " + (global.Member ?
"$2.00" : "$10.00"));<br>
path_start((global.level &gt; 10 ? path_hard : path_easy;), 2,
path_action_reverse, true);<br>
--hp &lt;= 0 ? instance_destroy() : score += 10;<span class="notranslate"></span></p><br> Es ist erwähnenswert, dass Sie bedingte Operationen verschachteln können. Wenn dies jedoch der Fall ist, muss jede Operation in Klammern eingeschlossen werden. Beispiel: <br><br><p class="code">var c = a ? "foo" : (b ? "bar" : "wii"); //
Correct<br>
var c = a ? "foo" : b ? "bar" : "wii";&nbsp;&nbsp; // Will cause an
error<span class="notranslate"></span></p></div><br> <label class="collapse" for="two"><span class=
"notranslate">repeat</span></label> <input id="two" type=
"checkbox"> <div class="index_list"> EIN <tt>"repeat"</tt> Aussage hat die Form <br><br><p class="code">repeat (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> Die Anweisung wird so oft wiederholt, wie durch den gerundeten Wert des Ausdrucks angegeben. Das folgende Programm erstellt beispielsweise fünf Kugeln an zufälligen Positionen. <br><br><p class="code">{<br>
repeat (5) instance_create_layer(random(400), random(400),
"Instances", obj_ball);<br>
}<br><span class="notranslate"></span></p><p><br> Dies kann sehr nützlich sein, um zu vermeiden, dass derselbe Code mehrmals eingegeben wird, Arrays verwendet werden oder eine Reihe von Operationen usw. gezählt werden. Zum Beispiel: <br><br></p><p class="code">{<br>
var i, total;<br>
i = 0;<br>
total = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;total += array[i];<br>
&nbsp;&nbsp;&nbsp;i += 1<br>
&nbsp;&nbsp;&nbsp;}<br>
draw_text(32, 32, total);<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="three"><span class=
"notranslate">while</span></label> <input id="three" type=
"checkbox"> <div class="index_list"> EIN <tt>"while"</tt> Aussage hat die Form <br><br><p class="code">while (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> Solange der Ausdruck wahr ist, wird die Anweisung (die auch ein Codeblock sein kann) ausgeführt. <b>Seien Sie vorsichtig mit Ihren while-Loops!</b> Sie können problemlos unendliche Schleifen erstellen. In diesem Fall hängt Ihr Spiel und reagiert nicht mehr auf Benutzereingaben. Im Folgenden finden Sie ein Beispiel für eine typische Verwendung von &quot;while&quot;: <br><br><p class="code">{<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Das obige Programm versucht, das aktuelle Objekt an einer freien Position zu platzieren (dies entspricht in etwa der Aktion zum Verschieben eines Objekts an eine zufällige Position). </div><br> <label class="collapse" for="four"><span class="notranslate">do / until</span></label> <input id="four" type="checkbox"> <div class="index_list"> Ein &quot;do&quot; ist wirklich das <tt>"do... until"</tt> Aussage, wie Sie nicht ohne das andere haben können. Es hat diese Form: <br><br><p class="code">do &lt;statement&gt; until (&lt;expression&gt;)<span class="notranslate"></span></p><br> Die Anweisung (die auch ein Codeblock sein kann) wird ausgeführt, bis der Ausdruck als wahr erkannt wird, und die ursprüngliche Anweisung wird immer mindestens einmal ausgeführt. Seien Sie vorsichtig mit Ihren do-Schleifen, da Sie sie leicht für immer in eine Schleife bringen können. In diesem Fall wird Ihr Spiel hängen bleiben und nicht mehr auf Benutzereingaben reagieren. Nachfolgend finden Sie ein Beispiel für eine typische Verwendung <tt>"do... until"</tt>: <br><br><p class="code">{<br>
do<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br>
until (place_free(x, y)); }<br><span class="notranslate"></span></p><br> Das obige Programm versucht, das aktuelle Objekt an einer freien Position zu platzieren (dies entspricht in etwa der Aktion zum Verschieben eines Objekts an eine zufällige Position). </div><br> <label class="collapse" for="five"><span class=
"notranslate">for</span></label> <input id="five" type="checkbox"> <div class="index_list"> EIN <tt>"for"</tt> Anweisung hat diese Form: <br><br><p class="code">for (&lt;assigment1&gt; ; &lt;expression&gt;
;&lt;statement1&gt;) &lt;statement2&gt;<span class="notranslate"></span></p><br> Dies funktioniert wie folgt: Zuerst wird assigment1 ausgeführt, dann wird der Ausdruck ausgewertet und, wenn er wahr ist, Anweisung2 ausgeführt. Dann wird Anweisung1 ausgeführt und der Ausdruck erneut ausgewertet. Diese Schleife wird fortgesetzt, bis der Ausdruck als falsch erkannt wird. <br><br> Nun, das hört sich vielleicht kompliziert an, wenn Sie so geschrieben werden, aber Sie sollten es folgendermaßen interpretieren: <br><br><ul><li> Die erste Anweisung initialisiert die for-Schleife. </li><li> Der Ausdruck prüft, ob die Schleife beendet werden soll. </li><li> Anweisung2 ist die &quot;Schritt&quot; -Anweisung, die zur nächsten Schleifenauswertung geht. </li></ul> Dies ist äußerst nützlich für sich wiederholende Aufgaben, bei denen mehrere Codezeilen auf andere Art und Weise erforderlich sind. Sie werden im Allgemeinen als Zähler für die Auswertung von Arrays oder zum Zeichnen von Objekten verwendet. Das folgende Codebeispiel veranschaulicht eine typische Verwendung für diesen Anweisungstyp: <br><br><p class="code">{<br>
for (var i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;draw_text(32, 32 + (i * 32), string(i) + ". "+
string(scr[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code initialisiert eine for-Schleife, die bei 0 beginnt und bis 9 hochzählt, und verwendet dann den Schleifenwert <span class=
"notranslate">&quot;i&quot;</span> um die in einem Array gespeicherten Werte auf den Bildschirm zu ziehen. Beachten Sie, wie die <tt>"for"</tt> Die Schleifenvariable <span class=
"notranslate">&quot;i&quot;</span> wird nicht nur verwendet, um das Array zu durchlaufen, sondern auch, um eine Zahl zu zeichnen und <i><span class="notranslate">GameMaker Studio</span> 2</i> mitzuteilen, wohin die Werte im Raum gezeichnet werden sollen. Diese Flexibilität ist einer der Hauptgründe dafür <tt>"for"</tt> Schleifen sind so wichtig bei der Programmierung. </div><br> <label class="collapse" for="six"><span class=
"notranslate">switch</span></label> <input id="six" type=
"checkbox"> <div class="index_list"> In einer Reihe von Situationen möchten Sie, dass Ihre Instanzen abhängig von einem bestimmten Wert eine Aktion ausführen. Sie können dies mit mehreren aufeinanderfolgenden Schritten tun. &quot; <tt>if</tt> &quot;Anweisungen, aber wenn die Auswahlmöglichkeiten über zwei oder drei hinausgehen, ist es normalerweise einfacher, die <tt>"switch"</tt> Aussage. EIN <tt>switch</tt> Die Anweisung hat folgende Form: <br><br><p class="code">switch (&lt;expression&gt;)<br>
{<br>
case &lt;expression1&gt;: &lt;statement1&gt;; ... ; break;<br>
case &lt;expression2&gt;: &lt;statement2&gt;; ... ; break;<br>
...<br>
default: &lt;statement&gt;;<br>
}<br><span class="notranslate"></span></p><br> Das funktioniert wie folgt: <br><br><ul><li> Zuerst wird der Ausdruck ausgeführt. </li><li> Als nächstes werden sie mit den Ergebnissen der verschiedenen Ausdrücke nach den einzelnen Case-Anweisungen verglichen. </li><li> Die Ausführung wird nach der ersten case-Anweisung mit dem korrekten Wert fortgesetzt, <i>bis eine break-Anweisung gefunden wird</i>. </li><li> Wenn keine case-Anweisung den richtigen Wert hat, wird die Ausführung nach der default-Anweisung fortgesetzt (es ist keine Standard-Anweisung erforderlich. In diesem Fall wird keine Aktion ausgeführt). </li></ul> Beachten Sie, dass mehrere Case-Anweisungen für dieselbe Anweisung platziert werden können. Außerdem ist der break nicht erforderlich. Wenn keine break-Anweisung vorhanden ist, wird die Ausführung einfach mit dem Code für die nächste case-Anweisung fortgesetzt. Dies bedeutet, dass Sie einen Hierarchie &quot;Switch&quot; erstellen können, in dem abhängig vom Eingabewert unterschiedliche Codeabschnitte ausgeführt werden. Hier ist ein Beispiel eines typischen <tt>"switch"</tt> aus einem spiel: <br><br><p class="code">{<br>
switch (keyboard_key)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;case vk_left:<br>
&nbsp;&nbsp;&nbsp;case ord("A"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_right:<br>
&nbsp;&nbsp;&nbsp;case ord("D"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_up:<br>
&nbsp;&nbsp;&nbsp;case ord("W"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y -= 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;case vk_down:<br>
&nbsp;&nbsp;&nbsp;case ord("S"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += 4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code verwendet <tt>"switch"</tt> um nach einem Tastaturereignis zu suchen, und vergleicht das mit den aufgeführten Fällen. Wenn es einen der erforderlichen Werte erfüllt, wird der entsprechende Code ausgeführt. Beachten Sie, wie wir im Code so vorgegangen sind <tt>"switch"</tt> kann mehrere Fälle prüfen und fortfahren, wenn keine Unterbrechung auftritt, damit verschiedene Schlüssel verwendet werden können, um dasselbe Ergebnis zu erzielen. Dies ist nur eine der Möglichkeiten, wie Sie mehrere Konfigurationen für die Bewegung in Ihren Spielen zulassen können. </div><br> <label class="collapse" for="seven"><span class=
"notranslate">break</span></label> <input id="seven" type=
"checkbox"> <div class="index_list"> Das <tt>"break"</tt> Anweisung wird verwendet, um vorzeitig zu beenden <tt>for</tt>. <tt>repeat</tt>. <tt>while</tt>. <tt>do... until</tt> Schleife irgendeiner Art, oder ein zu sagen <tt>switch</tt> Anweisung, an diesem Punkt zu enden oder vorzeitig zu beenden a <tt>with</tt> Anruf. Nachfolgend sehen Sie einige Beispiele, wie dies verwendet werden kann, und die Syntax ist einfach: <br><br><p class="code">break;<span class="notranslate"></span></p><br><p> &quot;Pause&quot; in einem <tt>for</tt> Schleife: <br><br></p><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = 234 break;<br>
&nbsp;&nbsp;&nbsp;}<br>
num = i;<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; in einem <tt>repeat</tt> Schleife: <br><br><p class="code">{<br>
var i, temp;<br>
i = 0;<br>
temp = 0;<br>
repeat (10)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;temp += array[i];<br>
&nbsp;&nbsp;&nbsp;if temp &gt; max_total break else i += 1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; in einem <tt>while</tt> Schleife: <br><br><p class="code">{<br>
var i;<br>
i = 0;<br>
while (!place_free(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;if i &gt; 50 break else i+=1;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> &quot;Pause&quot; bei der Verwendung <tt>with</tt>: <br><br><p class="code">{<br>
var count = 0;<br>
with (obj_Enemy)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;count++;<br>
&nbsp;&nbsp;&nbsp;if count &gt; 10 break;<br>
&nbsp;&nbsp;&nbsp;hp = 100;<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="eight"><span class=
"notranslate">continue</span></label> <input id="eight" type=
"checkbox"> <div class="index_list"> Das <tt>"continue"</tt> Aussage hat die Form: <br><br><p class="code">continue<span class="notranslate"></span></p><br> Wird innerhalb einer Anweisung verwendet, die eine Schleife bildet ( <tt>repeat</tt>. <tt>while</tt>. <tt>do... until</tt> oder <tt>for</tt> ) springt es sofort zum Anfang der Schleife, als ob die Schleife durchlaufen und zurückgeschleift worden wäre. Dies wird auch bei der Verwendung von geschehen <tt>with</tt> Funktion, bei der der Code zur nächsten Instanz springt und erneut ausgeführt wird, aber wenn er außerhalb des Kontextes verwendet wird, wird ein Fehler ausgegeben. <br><br> Nachfolgend ein Beispiel für die Verwendung in einer &quot;for&quot; -Schleife: <br><br><p class="code">{<br>
var i;<br>
for (i = 0; i &lt; 10; i += 1)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if array[i] = "" continue;<br>
&nbsp;&nbsp;&nbsp;array[i] = "";<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code springt zum Anfang der Schleife zurück, wenn der Array [i] -Wert bereits eine leere Zeichenfolge ist. </div><br> <label class="collapse" for="eleven"><span class=
"notranslate">exit</span></label> <input id="eleven" type=
"checkbox"> <div class="index_list"> Das <tt>"exit"</tt> Aussage hat die Form: <br><br><p class="code">exit;<span class="notranslate"></span></p><br> &quot;Exit&quot; beendet einfach die Ausführung des aktuellen Skripts oder Ereignisses. Beachten Sie, dass hier je nach Umfang ein geringfügiger Unterschied besteht: wenn Sie dies verwenden <tt>exit</tt> In einem Skript wird das Skript einfach beendet und es wird zu dem Code zurückgekehrt, der das Skript aufgerufen hat. Wenn Sie dieses Ereignis jedoch in einem Codeblock aus einem Objekt verwenden, wird <i>das gesamte Ereignis</i> auch dann beendet, wenn nach dem Skript verschiedene separate Codeblöcke vorhanden sind Funktion wurde aufgerufen. Normalerweise wird es verwendet, um zu vermeiden, dass eine Instanz einen bestimmten Codeblock ausführt, beispielsweise ein Kollisionsereignis. Der folgende Code gibt ein einfaches Beispiel dafür: <br><br><p class="code">{<br>
if !visible exit;<br>
while (place_meeting(x, y))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x -= lengthdir_x(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;y -= lengthdir_y(1, direction - 180);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Der obige Code prüft eine Variable und wenn sie in true aufgelöst wird, existiert der Codeblock, andernfalls wird der Rest des Codes ausgeführt. <div class="note"> <b>Hinweis:</b> Die Ausführung des Spiels wird dadurch nicht beendet. Dafür müssen Sie die Funktion nutzen <a href=
"../4_gml_reference/game/game_end.html"><tt>game_end</tt></a>. </div></div><br> <label class="collapse" for="nine"><span class=
"notranslate">with</span></label> <input id="nine" type="checkbox"> <div class="index_list"> Wie im Abschnitt <a hreff=
"7_Addressing_Variables.html">Adressieren von Variablen in anderen Instanzen angegeben</a>, ist es möglich, den Wert von Variablen in anderen Instanzen zu lesen und zu ändern. In einigen Fällen möchten Sie jedoch viel mehr als nur eine einzige Variable mit diesen anderen Instanzen ändern. Stellen Sie sich zum Beispiel vor, Sie möchten alle Ballobjekte in Ihrem Spiel um 8 Pixel verschieben. Sie können denken, dass dies einfach durch den folgenden Code erreicht wird: <br><br><p class="code">obj_ball.y = obj_ball.y + 8;<span class="notranslate"></span></p><br> Dies ist jedoch nicht korrekt, da die rechte Seite der Zuweisung den Wert der y-Koordinate des ersten Balls erhält und 8 addiert. Als Nächstes wird dieser neue Wert als y-Koordinate aller Bälle festgelegt. Das Ergebnis ist, dass alle Bälle dieselbe y-Koordinate erhalten, selbst wenn Sie Folgendes verwenden: <br><br><p class="code">obj_ball.y += 8;<span class="notranslate"></span></p><br> es wird genau dieselbe Wirkung haben, da es sich lediglich um eine Abkürzung der ersten Anweisung handelt. So wie erreichen wir das? Zu diesem Zweck gibt es die <b><tt>with</tt></b> Anweisung in GML. Ihre globale Form ist: <br><br><p class="code">with (&lt;expression&gt;) &lt;statement&gt;<span class="notranslate"></span></p><br> &lt;Ausdruck&gt; gibt eine oder mehrere Instanzen an. Dazu können Sie eine Instanz-ID, den Namen eines Objekts (das bedeutet, dass <i>alle Instanzen</i> dieses Objekts den Codeblock ausführen sollen) oder eines der speziellen <i>Schlüsselwörter</i> ( <b><tt>all</tt></b>. <b><tt>self</tt></b>. <b><tt>other</tt></b> ). &lt;Statement&gt; wird jetzt für jede der angegebenen Instanzen ausgeführt, als ob diese Instanz die aktuelle (Selbst-) Instanz ist. Um alle Instanzen des Ballobjekts um 8 Pixel nach unten zu verschieben, können Sie Folgendes eingeben: <br><br><p class="code">with (obj_ball) y += 8;<span class="notranslate"></span></p><br> Wenn Sie mehrere Anweisungen ausführen möchten, setzen Sie sie in geschweifte Klammern, wie Sie es auch in anderen Programmen tun würden. Um beispielsweise alle Bälle in eine zufällige Position zu bringen, können Sie Folgendes verwenden: <br><br><p class="code">with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x = random(room_width);<br>
&nbsp;&nbsp;&nbsp;y = random(room_height);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Beachten Sie, dass die angegebene Instanz innerhalb der Anweisung (en) zur Zielinstanz (Selbstinstanz) geworden ist, die den Codeblock ausführt. Dies bedeutet, dass die Anweisungen die ursprüngliche Instanz (die die <tt>"with"</tt> und der Codeblock) ist der geworden <b><tt>other</tt></b> Beispiel. Um beispielsweise alle Bälle an die Position der aktuellen Instanz zu verschieben, können Sie Folgendes eingeben: <br><br><p class="code">with (obj_ball) { x = other.x; y = other.y; }<span class="notranslate"></span></p><br> Die with-Anweisung ist ein äußerst leistungsfähiges Werkzeug und in vielen Situationen nützlich. Daher ist es wichtig, dass Sie vollständig verstehen, wie sie verwendet werden kann. Um zu helfen gibt es unten einige weitere Anwendungsbeispiele: <br><br><p class="code">with (instance_create_layer(x, y, "Instances",
obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;speed = other.speed;<br>
&nbsp;&nbsp;&nbsp;direction = other.direction;<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Der obige Code erstellt eine Instanz von obj_Ball und weist dieser die Geschwindigkeit und Richtung der Instanz zu, die den gesamten Codeblock ausführt. <br><br><p class="code">with (instance_nearest(x, y, obj_Ball))<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;instance_destroy();<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Der obige Code zerstört die Instanz von obj_Ball, die der Instanz, die den Code ausführt, am nächsten liegt. <br><br><p class="code">var inst;<br>
inst = noone;<br>
with (obj_ball)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if str &gt; other.str inst = id;<br>
&nbsp;&nbsp;&nbsp;}<br>
if inst != noone target = inst;<br><span class="notranslate"></span></p><br> Der obige Code ist etwas komplexer als der vorherige, da er eine lokale Variable verwendet. Diese Variable ist für das <i>Skript</i> lokal und nicht für die Instanz. Daher können alle Instanzen, auf die im Codeblock verwiesen wird, verwendet werden. Also haben wir es im Code auf das spezielle <i>Schlüsselwort gesetzt</i> <tt><b>noone</b></tt> tt&gt; und dann die &quot;with&quot; -Konstruktion, damit jede Instanz von obj_Ball ihre <span class=
"notranslate">&quot;str&quot;</span> -Variable mit der der Instanz, die den Codeblock ausführt, überprüft. Wenn der Wert der Variablen größer ist, speichern sie ihre eindeutige ID in der lokalen Variablen &quot;inst&quot;. Dies bedeutet, dass am Ende des Codes nur die Instanz mit einem Wert größer als die aufrufende Instanz (oder das <i>Schlüsselwort) ist</i> <b><tt>noone</tt></b> wenn keine größer sind) wird in der lokalen Variablen inst gespeichert. Weitere Informationen zu lokalen Variablen finden Sie im Abschnitt <a href="6_scope.html">Variablen und Variablenbereich</a>. </div><br> <label class="collapse" for="ten"><span class=
"notranslate">return</span></label> <input id="ten" type=
"checkbox"> <div class="index_list"> Das <tt>"return"</tt> Aussage hat die Form: <br><br><p class="code">return (&lt;expression&gt;)<br><span class="notranslate"></span></p><br> Sie benutzen nur die <tt>return</tt> Anweisung in <a href=
"../../2_interface/1_editors/scripts.html">Skripten</a>, und es wird verwendet, um einen Wert aus dem Skript zurückzugeben, der in weiteren Code- oder Skriptaufrufen verwendet werden soll. Es sollte beachtet werden, dass die <i>Ausführung des Skripts mit der return-Anweisung endet</i>, was bedeutet, dass Code, der nach dem Aufruf <i>der return-Anweisung kommt</i>, nicht ausgeführt wird. Hier ist ein kurzes Beispielskript namens &quot; <tt>scr_sqr</tt> &quot;, die das Quadrat des Wertes berechnet, der an ihn übergeben wird, und schließt Fehler ein, falls das übergebene Argument keine reelle Zahl ist: <br><br><p class="code">{<br>
if !is_real(argument0)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return 0;<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return (argument0 * argument0);<br>
&nbsp;&nbsp;&nbsp;}<br>
}<br><span class="notranslate"></span></p><br> Um ein Skript aus einem Codeabschnitt heraus aufzurufen, verhalten Sie sich genauso wie beim Aufruf von Funktionen. Schreiben Sie also den Skriptnamen mit den Argumentwerten in Klammern. Das obige Skript würde also so heißen: <br><br><p class="code">if keyboard_check_pressed(vk_enter)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;val = scr_sqr(amount);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="index.html">GML-Übersicht</a> </div><div style="float:right"> Weiter: <a href="1_code.html">Grundlegende Codestruktur</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
