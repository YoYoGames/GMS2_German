<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Bitweise Operatoren und binär </h2><div class="body-scroll"><p><br></p><p> Zu Beginn des Computerzeitalters waren binär und hexadezimal (Hexadezimal) eine Lebensweise, wahrscheinlich weil Hochsprachen (wie BASIC) einfach zu langsam waren. Heutzutage müssen Sie jedoch nicht mehr mit der Leistung eines durchschnittlichen PCs rechnen, und Sie können die Dinge auf die lange Sicht tun, da die Geschwindigkeit der Maschine und ihre komplexere CPU-Konstruktion jeden Kurzschluss ausgleicht comings diesen Ansatz hat. </p><p> Als ein sehr einfaches Beispiel hätte in der Vergangenheit die Multiplikation mit 32 möglicherweise mehrere CPU-Zyklen zur Ausführung benötigt, während eine einfache Binäroperation dasselbe getan hätte. Da Maschinen komplexer geworden sind, haben sie auch die Zeit verkürzt Viele komplexe Anweisungen benötigen, um zu laufen, so dass jetzt eine 32x32-Bit-Multiplikation nur einen Zyklus dauern kann - genau wie der binäre Operator. Das sind natürlich großartige Neuigkeiten, denn Sie müssen nicht mehr jede Codezeile optimieren, die Sie schreiben, aber wenn das der Fall ist - sollten Sie sich überhaupt für Binärdateien interessieren? </p><p> Die Antwort ist eindeutig &quot;Ja, du solltest&quot;. Es stimmt zwar, dass Sie immer noch etwas beschleunigen können - und manchmal können diese auch erheblich sein -, indem Sie binäre und hexadezimale Leads verwenden, um die CPU besser zu kennen und besser Code schreiben zu können, Daten besser packen zu können und einige Aufgaben zu erledigen viel einfacher. Diese Seite wird erklären, was binär ist und wie es benutzt werden kann, wenn Sie Ihre Spiele erstellen. </p><blockquote> <label class="collapse" for="one">Zahlentheorie</label> <input id="one" type="checkbox"><div class="index_list"> Sehen wir uns zunächst die grundlegendste binäre Theorie an - wie Zahlen erzeugt werden. Schau dir diese Tabelle an: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Jede 1 oder 0 repräsentiert ein einzelnes <i>Datenbit</i>, und wie Sie sehen, bedeutet dies, dass in binär 10 = 2 ist! Jedes Bit ist <i>zweimal so groß wie der vorherige Wert,</i> wobei das erste Bit gleich 1 ist. Also Bit 2 = 2, Bit 3 = 4, Bit 4 = 8 usw. (wie in dieser <i>Byte-</i> Tabelle gezeigt - ein Byte ist eine Sammlung von 8 Bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> Das ist in Ordnung, wenn Sie Zahlen mit einer Potenz von 2 möchten, aber wie erstellen wir komplexere Zahlen? Nun, eine einzelne Binärzahl kann nur eine 0 oder 1 speichern, und das ist es, also müssen wir für komplexere Zahlen Bits hinzufügen. Wenn wir zum Beispiel 6 machen wollten, würden wir 4 und 2 so addieren. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Dies gilt für <i>alle</i> Binärzahlen und wie der Computer intern eine Zahl bildet. Nehmen wir eine etwas kompliziertere Zahl als ein weiteres Beispiel: 23. Die Zahl 23 besteht eigentlich aus 1 + 2 + 4 + 16 oder 00010111. Wie wäre es mit einem viel komplexeren Beispiel: 196? Nun, das ist aus 128 + 64 + 4 oder 11000100 gemacht. Also eigentlich nicht so komplex. Wenn wir anfangen, Werte außerhalb des Bereichs eines Bytes zu machen (der Zahlen von 0 bis 255 speichern kann), wird es ein wenig schwieriger zu verfolgen. Zum Beispiel ist 217.361 binär 110101000100010001. Oder, 1 + 16 + 256 + etc... Die Regeln sind die gleichen, egal was der Wert ausgedrückt wird - jede Zahl wird durch das Hinzufügen mehrerer Bits zusammen erzeugt. </div><br> <label class="collapse" for="two">Binäre Operatoren</label> <input id="two" type="checkbox"><div class="index_list"> Was bedeutet das nun im Binärformat? Nun, nehmen wir an, Sie möchten einen speichern <tt>true</tt> oder <tt>false</tt> als ein Wert. Normalerweise verwenden Compiler einen INT (ein INT ist normalerweise als eine 32-Bit-Zahl mit Vorzeichen definiert) und weisen ihn dann einfach 0 oder 1 zu. Allerdings haben nur 2 Zustände, a <tt>true</tt> / <tt>false</tt> Wert ist ideal, um in einem Stück zu speichern, und wenn wir das taten, konnten wir 32 speichern <tt>true</tt> / <tt>false</tt> Bits für jeden INT statt nur einen. <br><br> Wie würden wir das machen? Nun, ziemlich leicht stellt sich heraus: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> Das &quot;|&quot; Der Operator ist ein <b>bitweises ODER</b>, und dies bedeutet, dass die obigen Instruktionen <b>OR</b> 1 in Flags sind. Wenn Sie sich von früher erinnern, wird das erste Bit mit einer 1 gesetzt. Wenn wir das zweite Bit setzen wollten, würden wir das tun: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Wir OR in 2, weil das Bitmuster 00000010 gleich 2 ist. Was also genau macht der binäre ODER-Operator? Nun, es fügt alle Bits zu einem einzigen Wert zusammen: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Hier ist, was als <i>Wahrheitstabelle</i> für den OR-Operator bekannt ist: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Wo also ein Wert mit 2 Nullen ist, wird es Null bleiben. Der Vorteil der Verwendung von BITS als True / False-Status besteht darin, dass Sie mehrere Flags in einer Operation setzen können, was Sie mit einem normalen booleschen Wert einfach nicht tun könnten. Nehmen wir an, Bit 1 ist ein &quot;aktives&quot; Flag und Bit 3 ist ein &quot;sichtbares&quot; Flag. Wir könnten <i>beides</i> festlegen: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> Dies liegt daran, dass 5 binär 00000101 ist und die Variable &quot;flags&quot; gemäß der obigen Regel beide diese 2 Bits mit ihren eigenen zusammenführt. Selbst wenn Bit 1 bereits gesetzt war, funktioniert die Operation immer noch und Bit 3 wird nun ebenfalls gesetzt. <br><br> Was ist mit Clearing-Flaggen? Nun, hier kommt die binäre UND-Operation ins Spiel. Wenn Sie AND etwas eingeben, werden die Bits, die in der Maske gesetzt sind, beibehalten, während die Bits, die in der Maske frei sind, entfernt werden - so: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Wie Sie sehen können, ist dort, wo ein Bit in jedem Wert ist, das Bit erhalten, und wo es eine Mischung oder Nullen und 1 gibt, werden diese auf 0 zurückgesetzt. Hier ist die Wahrheitstabelle für ANDing: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Also, nur wenn es an jedem Ort ein bisschen gibt, wird es behalten. Was dies bedeutet, ist, dass so wie Sie mehrere Flags zu <i>setzen</i> sind in der Lage, können Sie auch <i>klar</i> mehrere Fahnen auf einmal. Nehmen wir zum Beispiel den obigen Fall, aber löschen Sie ihn diesmal. Wir wollen die Bits 1 und 3 löschen (geben uns den Wert 5), aber wenn wir uns an die Wahrheitstabelle erinnern, wollen wir alle anderen Bits behalten und die Bits 1 und 3 löschen. Dies wäre eine binäre &quot;Maske&quot; &quot;von 11111111111111111111111111111010 (32 Bits). Diese Maske behält alle aktuell gesetzten Bits bei, löscht aber die zwei Bits, die wir tatsächlich löschen wollen. Also, wenn ich einen Wert von 1000111011 hätte und ich die Bits 1 und 3 mit der obigen Maske löschen wollte, würde ich damit enden... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> Das ist großartig, aber wenn wir jedes Mal, wenn wir die Flaggen räumen müssten, das ausarbeiten mussten, wäre das ermüdend. Was wir brauchen, ist eine Möglichkeit, Bits leicht umzukehren (und vorzugsweise ohne CPU-Kosten). Glücklicherweise gibt es einen einfachen Weg, dies mit dem NOT-Operator zu tun. <br><br> Der NOT-Operator ist genau das, was er sagt - NICHT diese Bits. Hier ist eine Wahrheitstabelle für NICHT. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Dieser Operator macht das Entfernen von Flags sehr einfach und noch besser, es ist normalerweise eine Kompilierzeit-Optimierung, was bedeutet, dass der Compiler die Bits automatisch für Sie umkehrt, wenn Sie eine konstante Zahl (dh keine Variable) verwenden. Nehmen Sie diese Aussage, wo wir die Bits 1 und 3 wieder löschen wollen: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Dies wird tatsächlich nur auf &quot;a &amp; 11111111111111111111111111111010&quot; kompiliert. Dies macht das Leben in Bezug auf das Löschen von Flaggen ziemlich einfach. <br><br> Der letzte Operator, den wir betrachten wollen, ist EOR (Exclusive OR, manchmal XOR genannt), dieser Operator dreht die in <i>beiden</i> Werten gesetzten Bits um. Hier ist die EOR-Wahrheitstabelle: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> Das ist eine kuriose, aber unglaublich nützliche Sache. Nehmen wir zum Beispiel an, wir möchten einen Zähler, der einfach von 0 bis 1 und zurück zu 0 zählt (zwischen 0 und 1), wir könnten eins hinzufügen und einen IF machen, um zu sehen, ob es 2 ist, und dann zurückstellen auf 1. Oder... wir könnten 1 hinzufügen und dann UND mit 1 (seit 01 + 01 = 10, und 10 &amp; 01 = 0) oder wir können dies tun: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Was das ist, ist das erste Mal durch 0 ^ 1 = 1, dann das zweite Mal 1 ^ 1 = 0, wodurch Dinge von 0 auf 1 hin- und hergeschaltet werden. <br><br> Also - ODER (|), AND (&amp;), NOT (~) und EOR (^) lassen uns Bits relativ leicht manipulieren, so dass wir auf der einfachsten Ebene mehrere Bits gleichzeitig steuern können. Wir können diese Operationen natürlich für andere Dinge verwenden, wenn wir unsere Spiele entwickeln, wie das Maskieren von Sprites, das Ausführen ganzzahliger MOD-Operationen (unter Verwendung von UND) oder das Ausführen von netten Schleifenzählern. </div><br> <label class="collapse" for="three">Einfache binäre Arithmetik</label> <input id="three" type="checkbox"><div class="index_list"> Wie fügt ein Computer hinzu? Nun, schauen wir uns ein sehr einfaches Beispiel 1 + 1 an. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Genau wie normale Additionen fügen wir Zahlen zusammen, und dann überfließen wir die nächste Spalte, aber im Gegensatz zu einer normalen Dezimaladdition können wir nur zu 1 gehen, nicht zu 9. Also fügen wir eine 1 + 1 hinzu bei einem komplexeren Beispiel. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> Es ist offensichtlich schwieriger, hier zu sehen, aber die Überläufe rauschen so lange, bis sich keine in einer Spalte befinden - oder 2, an diesem Punkt wird ein Überlauf-Bit 3 und es bleibt dort. Glücklicherweise müssen Sie sich darüber keine Gedanken machen, es sei denn, Sie möchten sehr große Zahlen hinzufügen (wie 2x128-Bit-Nummern). Es ist auch erwähnenswert, dass Computer nur 2 Zahlen auf einmal addieren (oder subtrahieren, multiplizieren oder dividieren) können, sogar SIMD basiert auf 2 Berechnungen auf einmal, aber macht mehrere Berechnungen parallel. Nimm 19 + 19 + 19. Als Mensch können wir alle 9 zusammen addieren, die 2 tragen und dann weiter! Aber Computer können das nicht tun - was sie tun <i>können</i>, ist: (19 + 19) + 19. Also werden sie jede Berechnung in Blöcken von 2 durchführen. <br><br> Die binären Berechnungen, die für uns von Interesse sind und von großem Nutzen sind, sind Multiplikation und Division. Computer multiplizieren nur in 2s, und um mehr zu tun, wird eine Zahl auseinander brechen und alle Ergebnisse zusammen hinzufügen. Lassen Sie uns zuerst einige sehr einfache Beispiele nehmen. 4 * 2 = 8. Jetzt multiplizieren wir alle Bits um 2 mit der Binärzahl 2. So was: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Alle Bits sind in diesem Fall um eins nach links gewandert, wodurch sie sich vom 3. Bit zum 4. und vom 4. zum 8. ändern. Wie wäre es mit einer größeren Zahl? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> Auch hier bewegen sich alle Bits auf einem, und das multipliziert sich mit 2. Also, wie wäre es mit einem Vielfachen von 4? Ganz einfach, wir verschieben alles um 2 und nicht um eins. Wie wäre es also mit 16 oder 128? Dies würde eine Linksverschiebung von 4 Bits bzw. 7 Bits erfordern. Das ist unglaublich nützlich. es bedeutet, dass wir einfache Multiplikationen durchführen können, indem wir einfach Bits umher bewegen. Dazu verwenden wir den SHIFT-Operator &lt;&lt;. Hier sind einige Beispiele: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Nun, abgesehen davon, dass es für schnelle / einfache Multiplikationen sehr nützlich ist, ist es auch sehr nützlich, um bestimmte BITs einzustellen, ohne den Bitwert herausfinden zu müssen. Nehmen wir an, wir wollten Bit 27 setzen, welche Nummer ist das? (67108864 übrigens!), Nun können wir die obige Syntax verwenden, um einfach solche Flags zu setzen: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> Okay... also eigentlich wäre das die Art und Weise, wie ich die Dinge bisher beschrieben habe (da die Bits schon bei 1 beginnen), aber eigentlich... beginnen die Bits bei Bit 0 und gehen aufwärts, nicht bei Bit 1 Wenn also 32 Bits in einem INTEGER sind, reichen die Bits von 0 bis 31, nicht von 1 bis 32. Dies ist tatsächlich ziemlich nützlich, da wir nun CONSTANTS für Bitnummern einrichten können. <br><br> Nehmen wir an, Bit 27 ist ein aktives Flag und Bit 0 ist ein explodierendes Flag. Wie können wir beides einstellen? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Dies kann wie viel Code aussehen, aber wenn diese Zahlen Konstanten sind, kompiliert der Compiler diese Operationen in einen einzigen Wert, so dass wir damit als tatsächlichen Code enden. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Das Löschen dieser Bits (wie wir oben gesehen haben) ist einfach eine Frage der Verwendung des NOT-Modifikators, wie folgt: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> So können wir glücklicherweise alle Bits setzen und löschen, und wir können Datenstrukturen massiv komprimieren. Das Komprimieren von Datenstrukturen ist eine gute Sache, denn wenn Sie weniger Speicher verwenden, erhalten Sie weniger Cache-Fehler und Ihr Code läuft schneller. Sagen Sie es so, was ist schneller, kopieren 32Mbytes oder Daten oder 4Mbytes? Nun, ganz klar ist 4. Also, wenn Sie alle Ihre Flaggen in einen einzigen Speicherzugriff packen können, ist das gut! </div><br> <label class="collapse" for="four">Binäre Abteilung</label> <input id="four" type="checkbox"><div class="index_list"> Lassen Sie uns einen kurzen Blick darauf werfen, wie Sie die Division durchführen und warum sie so nützlich sein wird. Nehmen wir eine einfache Zahl - 64 - und dividieren durch 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Also schiebst du das einzelne Bit um 5 <i>runter</i> (was die Anzahl der für 32 benötigten Verschiebungen ist - schau oben), was uns 2 gibt. Aber was passiert, wenn hier andere Bits drin sind? Schauen wir uns mal an: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Hier bitteschön…. Es ist genau dasselbe. Die Bits, die wir herunterschalten, sind einfach verloren. Das ist wirklich sehr nützlich, denn wenn wir den Rest aufteilen, gibt es einen noch einfacheren Weg, um es zu bekommen. Wir kommen gleich dazu. Aber nehmen wir zuerst ein praktisches Beispiel. Ich habe eine X- und Y-Position, und ich möchte die Rasterzelle erhalten, in die das Raster 32x32 groß ist. Diese Methode ermöglicht es, Objekte, Kollisionen, Flaggen - alle möglichen Dinge zu speichern und sehr schnell darauf zuzugreifen. Auf geht&#39;s: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> Das ist schnell, sehr schnell. Dies vermeidet die Notwendigkeit einer Gleitkommadivision und dann eine floor () Berechnung - was alles summiert. <br><br> Also, was ist, wenn wir den Rest wollen? Vielleicht wird dieser Rest als irgendeine Art von Ordnung oder etwas verwendet, was auch immer der Grund ist, einen Rest zu bekommen ist so einfach wie ein AND: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Nun, die scharfsichtigen unter euch haben vielleicht bemerkt, dass wir beide hier benutzt haben (wie so oft), aber das sind nur ein paar Anweisungen. Aber warum die 31? Nun, da Bit 5 32 ist, dann wären alle darunter liegenden Bits 31, und das ist der maximale Rest, also ist das was wir UND mit (wir könnten auch verwenden ((1 &lt;&lt; 5) -1), was 32-1 = machen würde 31. Wenn ich dies tun würde, ohne Binär zu verstehen, würde es so aussehen: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Warum ist das viel schlimmer? Nun, um durch 32 zu teilen, müssen wir eine Gleitkommadivision durchführen - was offensichtlich Zeit braucht, aber um den Mod 32 zu machen, müssen Sie tatsächlich einen anderen tun! Wenn wir das in Assembler machen, bekommen wir tatsächlich BEIDE Werte in einem Teil, aber Sie bekommen das nicht in Hochsprachen (naja... nicht sehr oft), und Sie müssen die ganze Arbeit zweimal machen. Dies summiert sich, besonders wenn Sie eine enge Schleife mit vielen Berechnungen wie diesem machen. Ganzzahlige Unterteilung wie oben gezeigt, hilft Ihnen dabei, Ihr Spiel zu optimieren. </div></blockquote><p><br></p><h2> Beispiele </h2><p><br></p><p> Da dies ein ziemlich komplexes Konzept sein kann, um es zu erfassen und dann auf reale Programmiersituationen anzuwenden, finden Sie unten eine Reihe von kurzen Beispielen, die auf jedes mit <i><span class="notranslate">GameMaker Studio 2</span></i> Spiel angewendet werden können. </p><blockquote> <label class="collapse" for="five">Kachelausrichtung</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> Entwickler verwenden diese Funktion häufig <tt>place_free()</tt> Wenn Sie eine Kollision gefunden haben, versuchen Sie, das Objekt langsam zu verschieben, indem Sie entweder um eine x - oder y - Position (oder etwas) herumlaufen, während Sie diese Funktion weiterhin ausführen, oder indem Sie die Option verwenden <tt>move_outside_all()</tt> Funktion. <br><br> Also, was ist der schnellere Weg, dies zu tun? Nun, wenn wir richtige Potenz-2-Kacheln verwenden, haben wir eine sehr einfache Methode, die auch blitzschnell ist. Wenn wir uns nach rechts bewegen und in einen Kollisionsblock gezogen sind, dann ist, wie wir wissen, alles an 32 ausgerichtet, also müssen wir das Sprite auch auf eine 32-Pixel-Grenze ausrichten - vorzugsweise auf die linke -, also auf das Sprite wird aus der Kollision bewegt. Das ist wirklich einfach, da wir die Regeln kennen, die wir oben verwendet haben, um den Rest zu erhalten, und zu wissen, wie man die Umkehrung von Bits erhält, können wir das einfach tun: <br><br><p class="code">X = x&amp;~31;<br><span class="notranslate"></span></p><br> Das stimmt, das ist alles, was man braucht, um sich auf eine 32-Pixel-Grenze auszurichten. Indem wir die 31 ändern, können wir uns auf alles ausrichten, was wir wollen - solange es eine Potenz von 2 ist. (Dies ist das Äquivalent von Division durch 32, dann Multiplikation mit 32, wodurch die unteren Bits entfernt werden.) <br><br> Wenn wir nach rechts ausrichten wollten, würden wir das obige tun, aber dann 32 hinzufügen, um es in die nächste Kachel zu verschieben. Einfach. All dies macht den gesamten Kollisionscode monumental schneller und lässt Sie die CPU-Zeit dort verbringen, wo Sie sie wirklich benötigen. </div><br> <label class="collapse" for="six">Schlüssel und Türen</label> <input id=
"six" type="checkbox"><div class="index_list"> Angenommen, Sie haben eine Ebene mit ein paar Türen und jeweils einen Schlüssel. Wie können Sie einfach einen Schlüssel für einen Schlüssel markieren? Nun, normalerweise würden Sie dem Schlüssel und der Tür einfach eine ID zuweisen. Was also, wenn Sie einen Schlüssel zum Öffnen von 2 oder 3 Türen wünschen? Einfach. Du benutzt eine MASKE. Die Tür hätte ein einzelnes &quot;Bit&quot; zugewiesen wie door_id = 1 (0001), ein anderes mit door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000) und so weiter. Wenn wir möchten, dass der Schlüssel Tür 1 und 3 öffnet, dann würde der Schlüssel die MASKE von 5 haben (was 101 in binär ist). Wenn wir ein UND davon ausführen, und es &quot;nicht Null&quot; herauskommt, dann wissen wir, ob der Schlüssel die Tür öffnen kann. Sie könnten auch Schlüssel haben, die nichts geöffnet haben, indem Sie eine MASKE von 0 haben. Sehen Sie den Code unten für den tatsächlichen Scheck: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Schleifenzähler</label> <input id="seven" type="checkbox"><div class="index_list"> Nehmen wir an, wir wollen einen einfachen Animationszähler, der von 0 bis 15 zählt (da wir 16 Animationsrahmen haben), jetzt können wir entweder ein Inkrement machen und dann ein IF machen, oder wir können unser Wissen über Binär benutzen und das entfernen WENN komplett. IFs sind langsam, und wenn wir sie nicht brauchen, sollten wir sie entfernen. <br><br><p class="code">counter = (counter+1)&amp;31;<br><span class="notranslate"></span></p><br> Da 16 Frames eine Potenz von 2 Zahlen sind, und da 0 im Zähler enthalten ist, können wir die POW2-Nummer um 1 reduzieren und sie als MASK verwenden, und damit können wir unseren Zähler umhüllen. Wenn der Zähler von 15 auf 16 wechselt, endet das Bitmuster 10000, und wenn wir dann AND mit 15 (Bitmuster 01111) haben, endet der Wert mit 0. Das bedeutet, dass der obige Code zum Umbrechen von Zählern unglaublich nützlich ist - solange Sie verwenden POW2-Bildnummern. </div><br> <label class="collapse" for="eight">Leistung von 2 prüfen</label> <input id="eight" type="checkbox"><div class="index_list"> Was, wenn du überprüfen möchtest, ob etwas eine Stärke von 2 ist? Nun, hier ist ein hübscher kleiner Trick. Dies wird TRUE zurückgeben, wenn argument0 eine Potenz von 2 ist. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Wenn wir also die Nummer 51 (110011) haben, was macht das? Nun, wir bekommen das... 110011 &amp; 110010, was uns offensichtlich mit FALSE zurücklässt, da nach dem AND noch viele &quot;Bits&quot; übrig sind. Wenn wir 64 1000000 hatten, dann wird es das... 1000000 &amp; 0111111, was uns 0 lässt, also ist es WAHR. </div><br> <label class="collapse" for="nine">Indexausrichtung</label> <input id="nine" type="checkbox"><div class="index_list"> Hier ist ein kurzer Code für die Ausrichtung von 2 Zahlen. (1,2,4,8,16 und so weiter). Dies kann für die Speicherzuweisung sehr nützlich sein oder dafür sorgen, dass Sie Daten in die richtigen Grenzen schreiben. In diesem Beispiel muss argument0 mit argument1 bytes abgeglichen werden, wobei argument1 eine Potenz der Zahl 2 ist. Dieses kleine Skript wird auf die nächste Grenze der gewünschten Zahl aufgerundet. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="index.html">Zusätzlicher Informationsindex</a> </div><div style="float:right"> Next: <a href="errors.html">Compilerfehler</a> </div></div></div><h5> © Urheberrecht <span class="notranslate">YoYo Games Ltd.</span> 2017 Alle Rechte vorbehalten </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
