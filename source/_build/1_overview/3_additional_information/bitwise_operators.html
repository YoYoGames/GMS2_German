<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Bitweise Operatoren und binär </h2><div class="body-scroll"><p><br></p><p> Zu Beginn des Computerzeitalters waren binär und hexadezimal (hexadezimal) eine Lebensweise, wahrscheinlich weil Hochsprachen (wie BASIC) einfach zu langsam waren. Heutzutage müssen Sie jedoch selbst mit der Leistung eines durchschnittlichen PC nichts mehr wissen, und Sie können lange Dinge tun, da die Geschwindigkeit der Maschine und die komplexere CPU-Konstruktion den Nachteil ausgleichen Kommen dieser Ansatz hat. </p><p> Als sehr einfaches Beispiel hat das Multiplizieren mit 32 in der Vergangenheit möglicherweise mehrere CPU-Zyklen zur Ausführung benötigt, während eine einfache binäre Operation für die gleiche Aufgabe nur 1 benötigt hätte. Da Maschinen komplexer geworden sind, haben sie auch die Zeit verkürzt Viele komplexe Anweisungen müssen ausgeführt werden, so dass ein 32x32-Bit-Multiplikator nur einen Zyklus benötigen kann - genau wie der binäre Operator. Dies ist natürlich eine großartige Neuigkeit, da Sie nicht mehr jede Zeile Code optimieren müssen, die Sie schreiben, aber wenn dies der Fall ist - sollten Sie sich wirklich für die Binärdarstellung interessieren? </p><p> Die Antwort lautet definitiv &quot;Ja, Sie sollten&quot;. Es ist zwar wahr, Sie können jedoch noch einige Beschleunigungen erhalten - und dies kann manchmal von Bedeutung sein -, wenn Sie die Binär- und Hex-Werte verwenden, können Sie die CPU besser kennen. Außerdem können Sie besseren Code schreiben, Daten besser packen und einige Aufgaben erledigen viel einfacher. Diese Seite wird ein wenig erklären, was binär ist und wie es verwendet werden kann, wenn Sie Ihre Spiele erstellen. </p><blockquote> <label class="collapse" for="one">Zahlentheorie</label> <input id="one" type="checkbox"><div class="index_list"> Schauen wir uns zuerst die grundlegendste Binärtheorie an - wie Zahlen erstellt werden. Schauen Sie sich diese Tabelle an: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Jede 1 oder 0 steht für ein einzelnes <i>Datenbit</i>, und wie Sie sehen können, bedeutet dies, dass 10 binär in 2 ist! Jedes Bit ist das <i>2-fache des vorherigen Werts,</i> wobei das erste Bit gleich 1 ist. Also ist Bit 2 = 2, Bit 3 = 4, Bit 4 = 8 usw. (wie unten in dieser <i>Bytentabelle gezeigt</i> - ein Byte ist eine Sammlung von 8 Bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> Das ist in Ordnung, wenn Sie Zahlen mit einer Potenz von 2 wünschen, aber wie erstellen wir komplexere Zahlen? Nun, eine einzelne Binärzahl kann nur eine 0 oder 1 speichern, und das ist es auch. Für komplexere Zahlen müssen wir Bits addieren. Wenn wir zum Beispiel 6 machen wollten, würden wir 4 und 2 zusammen hinzufügen. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Dies gilt für <i>alle</i> Binärzahlen und wie der Computer intern eine beliebige Zahl ausmacht. Nehmen wir als weiteres Beispiel eine etwas kompliziertere Zahl: 23. Die Zahl 23 setzt sich eigentlich aus 1 + 2 + 4 + 16 oder 00010111 zusammen. Wie wäre es mit einem viel komplexeren Beispiel: 196? Nun, das ist aus 128 + 64 + 4 oder 11000100 gemacht. Also eigentlich nicht so komplex. Wenn wir anfangen, Werte außerhalb des Bereichs eines Bytes (das Zahlen von 0 bis 255 speichern kann) auszuführen, wird es etwas schwieriger zu verfolgen. Zum Beispiel ist 217.361 binär 110101000100010001. Oder 1 + 16 + 256 + etc... Die Regeln sind gleich, egal wie der Wert ausgedrückt wird - jede Zahl wird durch Addition mehrerer Bits erstellt. </div><br> <label class="collapse" for="two">Binäre Operatoren</label> <input id="two" type="checkbox"><div class="index_list"> Was bedeutet das nun binär? Nehmen wir an, Sie möchten eine speichern <tt>true</tt> oder <tt>false</tt> als Wert. Normalerweise verwenden Compiler ein INT (ein INT wird normalerweise als 32-Bit-Nummer mit Vorzeichen definiert) und weisen es dann einfach 0 oder 1 zu. Wenn Sie jedoch nur 2 Zustände haben, a <tt>true</tt> / <tt>false</tt> value ist ideal, um etwas zu speichern, und wenn wir dies tun, könnten wir 32 speichern <tt>true</tt> / <tt>false</tt> Bits für jeden INT und nicht nur einen. <br><br> Wie machen wir das? Nun, es stellt sich leicht heraus: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> Das &quot;|&quot; Operator ist ein <b>bitweises ODER</b>, und dies bedeutet, dass die obigen Anweisungen 1 in Flags sind. Wenn Sie sich an früher erinnern, wird mit einer 1 das erste Bit gesetzt. Wenn wir das zweite Bit setzen wollten, würden wir Folgendes tun: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Wir ODER in 2, weil das Bitmuster 00000010 gleich 2 ist. Was genau macht also der binäre ODER-Operator? Nun, es werden alle Bits zu einem einzigen Wert zusammengefügt: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Was als <i>Wahrheitstabelle</i> für den OR-Operator bekannt ist: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Wo also ein Wert mit 2 Nullen vorhanden ist, bleibt er Null. Der Vorteil der Verwendung von BITS als True / False-Status besteht darin, dass Sie in einem Vorgang mehrere Flags setzen können. Dies ist mit einem normalen booleschen Wert einfach nicht möglich. Angenommen, Bit 1 ist ein &quot;aktives&quot; Flag und Bit 3 ist ein &quot;sichtbares&quot; Flag. Wir könnten <i>beides</i> einstellen: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> Dies ist darauf zurückzuführen, dass 5 binär 00000101 ist. Gemäß der obigen Regel werden die Variablen &quot;flags&quot; diese beiden Bits mit ihren eigenen kombinieren. Auch wenn bereits Bit 1 gesetzt wurde, funktioniert die Operation immer noch und Bit 3 wird jetzt ebenfalls gesetzt. <br><br> Was ist mit dem Löschen von Flaggen? Nun, hier kommt die binäre UND-Verknüpfung ins Spiel. Wenn Sie UND etwas die in der Maske gesetzten Bits beibehalten, werden die in der Maske leeren Bits entfernt - wie folgt: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Wie Sie sehen, wird, wenn in jedem Wert ein Bit enthalten ist, das Bit beibehalten, und wenn es eine Mischung oder 0 und 1 gibt, werden diese auf 0 zurückgesetzt. Hier ist die Wahrheitstabelle für die AND-Verknüpfung: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Nur wenn es an jedem Ort etwas gibt, wird es behalten. Was dies bedeutet, ist, dass so wie Sie mehrere Flags zu <i>setzen</i> sind in der Lage, können Sie auch <i>klar</i> mehrere Fahnen auf einmal. Nehmen wir zum Beispiel den obigen Fall, aber klären Sie diesmal. Wir wollen die Bits 1 und 3 löschen (geben uns den Wert 5), aber wenn wir uns an die Wahrheitstabelle oben erinnern, wollen wir alle anderen Bits und die Bits 1 und 3 löschen. Dies wäre eine binäre &quot;Maske&quot; &quot;von 111111111111111111111111111010 (32 Bit). Diese Maske behält alle aktuell gesetzten Bits bei, löscht jedoch die zwei Bits, die tatsächlich gelöscht werden sollen. Wenn also ein Wert von 1000111011 vorhanden wäre und ich die Bits 1 und 3 mit der obigen Maske löschen wollte, würde ich damit enden... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> Das ist großartig, aber wenn wir dies jedes Mal klären müssten, wenn wir Flaggen löschen mussten, würde dies mühsam werden. Was wir brauchen, ist eine Möglichkeit, Bits leicht zu kippen (vorzugsweise ohne CPU-Kosten). Glücklicherweise gibt es eine einfache Möglichkeit, den NOT-Operator zu verwenden. <br><br> Der NOT-Operator ist genau das, was er sagt - NICHT diese Bits. Hier ist eine Wahrheitstabelle für NICHT. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Dieser Operator macht das Entfernen von Flags sehr einfach und noch besser: Normalerweise ist es eine Optimierung der Kompilierzeit. Wenn Sie eine konstante Zahl verwenden (dh keine Variable), werden die Bits automatisch vom Compiler umgedreht. Nehmen wir diese Anweisung an, wenn wir die Bits 1 und 3 wieder löschen möchten: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Dies wird tatsächlich zu &quot;a &amp; 111111111111111111111111111010&quot; kompiliert. Dies macht das Leben in Bezug auf das Löschen von Flaggen ziemlich einfach. <br><br> Der letzte Operator, den wir betrachten wollen, ist EOR (Exclusive OR, manchmal auch XOR genannt). Dieser Operator dreht die in <i>beiden</i> Werten gesetzten Bits um. Hier ist die EOR-Wahrheitstabelle: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> Dies ist eine merkwürdige, aber unglaublich nützlich. Nehmen wir zum Beispiel an, wir möchten einen Zähler, der einfach von 0 bis 1 und zurück auf 0 zählt (zwischen 0 und 1 umschalten). Wir könnten einen hinzufügen und eine IF durchführen, um zu sehen, ob er auf 2 steht, und ihn dann zurückzusetzen 1. Oder... wir könnten 1 hinzufügen und dann AND mit 1 (seit 01 + 01 = 10 und 10 &amp; 01 = 0) oder wir können dies tun: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Was dies tut, ist das erste Mal 0 ^ 1 = 1, dann das zweite Mal 1 ^ 1 = 0, wodurch die Dinge von 0 auf 1 hin und her geschaltet werden. <br><br> Also lassen sich mit OR (|), AND (&amp;), NOT (~) und EOR (^) Bits relativ einfach bearbeiten, so dass wir auf einfachster Ebene mehrere Bits gleichzeitig steuern können. Wir können diese Operationen natürlich für andere Dinge verwenden, wenn wir unsere Spiele entwickeln, wie zum Beispiel das Maskieren von Sprites, das Ausführen ganzer MOD-Operationen (mit UND) oder das Durchführen von schönen Schleifenzählern. </div><br> <label class="collapse" for="three">Einfache binäre Arithmetik</label> <input id="three" type="checkbox"><div class="index_list"> Wie fügt ein Computer hinzu? Nun, schauen wir uns ein sehr einfaches Beispiel 1 + 1 an. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Genau wie bei normalen Hinzufügungen addieren wir Zahlen und laufen dann in die nächste Spalte über, aber im Gegensatz zu einer normalen Dezimaladdition können wir nur 1 und nicht 9 gehen. Wenn Sie also eine 1 + 1 hinzufügen, überschreiten wir 10 bei einem komplexeren Beispiel. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> Es ist offensichtlich schwieriger, hier zu sehen, aber die Überläufe laufen so lange, bis keine in einer Spalte sind - oder 2, an denen ein Überlaufbit 3 ergibt und dort bleibt. Glücklicherweise müssen Sie sich nie darüber Gedanken machen, es sei denn, Sie möchten sehr große Zahlen hinzufügen (z. B. 2x128bit-Zahlen). Es ist auch erwähnenswert, dass Computer nur zwei Zahlen gleichzeitig hinzufügen (subtrahieren, multiplizieren oder dividieren) können, selbst SIMD basiert auf zwei Berechnungen gleichzeitig, führt jedoch mehrere Berechnungen parallel aus. Nimm 19 + 19 + 19. Als Mensch können wir alle 9 zusammen hinzufügen, die 2 tragen und dann geht es weiter! Aber Computer können das nicht - was sie <i>können</i>, ist folgendes: (19 + 19) + 19. Also führen sie jede Berechnung in Blöcken von 2 aus. <br><br> Die binären Berechnungen, die für uns von Interesse sind und von großem Nutzen sind, sind Multiplikation und Division. Computer multiplizieren sich nur in 2s, und um mehr zu tun, wird eine Zahl getrennt, und dann werden alle Ergebnisse addiert. Nehmen wir zunächst einige sehr einfache Beispiele. 4 * 2 = 8. Um nun binär mit 2 zu multiplizieren, verschieben wir alle Bits um eins nach LINKS. So was: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Alle Bits sind in diesem Fall um eins nach links verschoben, bewegen sich dabei vom 3. Bit zum 4. Bit und ändern den Wert von 4 auf 8. Wie wäre es mit einer größeren Zahl? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> Wieder bewegen sich alle Bits um eins und das Vielfache um 2. Wie sieht es also mit einem Vielfachen von 4 aus? Ganz einfach, wir verschieben alles, was übrig ist, um zwei statt um eins. Wie wäre es mit 16 oder 128? Dies würde eine Linksverschiebung von 4 Bit bzw. 7 Bit erfordern. Das ist unglaublich nützlich. Das bedeutet, dass wir einfache Multiplikationen durchführen können, indem Sie einfach Bits verschieben. Dazu verwenden wir den SHIFT-Operator &lt;&lt;. Hier sind einige Beispiele: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Abgesehen davon, dass es für schnelle / einfache Multiplikationen sehr nützlich ist, ist es auch sehr nützlich, um bestimmte BITs festzulegen, ohne den Bitwert ermitteln zu müssen. Angenommen, wir wollten Bit 27 setzen. Welche Zahl ist das? (67108864 übrigens!), Gut können wir die obige Syntax verwenden, um Flags wie folgt zu setzen: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> Okay... also eigentlich wäre das Bit 26 so, wie ich es bisher beschrieben habe (da Bits bei eins angefangen haben), aber eigentlich... Bits beginnen bei Bit 0 und gehen aufwärts, nicht bei Bit 1 Während also 32 Bits in einem INTEGER vorhanden sind, reichen die Bits von 0 bis 31 und nicht von 1 bis 32. Dies ist sehr nützlich, da wir jetzt CONSTANTS für Bitnummern einrichten können. <br><br> Nehmen wir an, Bit 27 ist ein aktives Flag und Bit 0 ist ein explodierendes Flag. Wie können wir beides einstellen? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Das kann wie viel Code aussehen, aber wenn diese Zahlen Konstanten sind, kompiliert der Compiler diese Operationen in einen einzigen Wert, so dass wir diesen Code als tatsächlichen Code verwenden. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Wenn Sie diese Bits löschen (wie oben beschrieben), verwenden Sie einfach den Modifikator NOT, wie folgt: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> So können wir glücklich alle gewünschten Bits setzen und löschen und Datenstrukturen massiv komprimieren. Das Komprimieren von Datenstrukturen ist eine gute Sache, denn wenn Sie weniger Arbeitsspeicher verwenden, erhalten Sie weniger Cache-Fehler und Ihr Code wird schneller ausgeführt. Um es so auszudrücken: Was ist schneller? Kopieren von 32 MB oder Daten oder 4 MB? Naja, ganz klar 4 ist. Wenn Sie also alle Ihre Flaggen in einen einzigen Speicherzugriff packen können, ist dies gut! </div><br> <label class="collapse" for="four">Binäre Division</label> <input id="four" type="checkbox"><div class="index_list"> Lassen Sie uns einen kurzen Blick darauf werfen, wie Sie die Division durchführen und warum es so nützlich sein wird. Nehmen wir eine einfache Zahl - 64 - und dividieren durch 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Da verschiebt man also das einzelne Bit um 5 nach <i>unten</i> (wie viele Schichten sind für 32 erforderlich - siehe oben), wodurch wir 2 erhalten. Was passiert, wenn hier andere Bits sind? Nun schauen wir mal: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Hier bitteschön…. Es ist genau das gleiche. Die Bits, die wir nach unten verschieben, gehen einfach verloren. Das ist wirklich sehr nützlich, denn wenn wir den Rest aufteilen, gibt es einen noch einfacheren Weg, dies zu erreichen, und wir werden es gleich tun. Nehmen wir aber zunächst ein praktisches Beispiel. Ich habe eine X- und Y-Position, und ich möchte die Rasterzelle erhalten, in die das Raster fällt, wobei das Raster eine Größe von 32 x 32 hat. Diese Methode erlaubt es, Objekte, Kollisionen, Flaggen aller Art zu speichern und sehr schnell darauf zuzugreifen. Auf geht&#39;s: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> Das geht schnell, sehr schnell. Dies vermeidet die Notwendigkeit, eine Fließkommadivision durchzuführen und dann eine floor () - Berechnung durchzuführen - was alles summiert. <br><br> Was wäre, wenn wir den Rest wollten? Vielleicht wird dieser Rest als eine Art Ordnung oder etwas verwendet, was auch immer der Grund ist, einen Rest zu bekommen, ist so einfach wie ein AND: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Nun, die Scharfsichtigen unter Ihnen haben vielleicht bemerkt, dass wir beide hier verwendet haben (wie so oft), aber dies sind immer noch nur ein paar Anweisungen. Aber warum die 31? Nun, da Bit 5 32 ist, dann wären alle Bits unten 31, und das ist der maximale Rest, also ist es das, was wir UND mit (wir könnten auch ((1 &lt;&lt; 5) -1) verwenden), was 32-1 = ergibt 31. Nun, wenn ich dies ohne Verständnis für binär tun würde, würde es so aussehen: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Warum ist das so viel schlimmer? Nun, um durch 32 zu dividieren, müssen wir eine Fließkommadifferenz ausführen - was natürlich Zeit braucht, aber um den Mod 32 zu machen, muss man tatsächlich eine andere machen! Wenn wir dies in Assembler machen, erhalten wir tatsächlich BEIDE Werte in einer Division, aber Sie werden dies nicht in Hochsprachen (naja… nicht sehr oft) und Sie müssen also die ganze Arbeit zweimal machen. Das summiert sich, besonders wenn Sie eine enge Schleife mit vielen Berechnungen wie dieser durchführen. Ganzzahlige Teilungen wie oben gezeigt helfen wirklich, Ihr Spiel zu optimieren. </div></blockquote><p><br></p><h2> Beispiele </h2><p><br></p><p> Da dies ein recht komplexes Konzept sein kann, das Sie verstehen und dann auf reale Programmiersituationen anwenden können, finden Sie nachfolgend eine Reihe kurzer Beispiele, die auf jedes mit <i><span class="notranslate">GameMaker Studio 2</span></i> Spiel angewendet werden können. </p><blockquote> <label class="collapse" for="five">Fliesenausrichtung</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> Entwickler verwenden häufig die Funktion <tt>place_free()</tt> Wenn Sie eine Kollision gefunden haben, bewegen Sie das Objekt langsam heraus, indem Sie entweder eine x - oder y - Position (oder etwas anderes) umlaufen, während Sie die Funktion fortsetzen, oder indem Sie die <tt>move_outside_all()</tt> Funktion. <br><br> Also, wie geht das schneller? Wenn wir richtige Power-of-2-Kacheln verwenden, haben wir eine sehr einfache Methode, die auch blitzschnell ist. Wenn wir uns nach rechts bewegen und in einen Kollisionsblock geraten sind, ist, da wir wissen, dass alles auf 32 ausgerichtet ist, wir müssen das Sprite auch an einer 32-Pixel-Grenze ausrichten - vorzugsweise an der linken Seite - also am Sprite wird aus der Kollision herausbewegt. Dies ist sehr einfach, da wir die oben genannten Regeln kennen, um den Rest zu erhalten, und wissen, wie man die Umkehrung der Bits erhält, können wir einfach Folgendes tun: <br><br><p class="code">x = x&amp;~31;<br><span class="notranslate"></span></p><br> Das ist richtig, das ist alles, was es braucht, um eine 32-Pixel-Grenze auszurichten. Durch das Ändern der 31 können wir uns an alles anpassen, was wir möchten - solange es eine Potenz von 2 ist. (Dies ist das Äquivalent der Division durch 32 und der Multiplikation mit 32, wodurch die unteren Bits entfernt werden.) <br><br> Wenn wir uns nach rechts ausrichten wollten, tun wir das oben, aber fügen dann 32 hinzu, um es in die nächste Kachel zu verschieben. Einfach. Dadurch wird der gesamte Kollisionscode um ein Vielfaches schneller und Sie können die CPU-Zeit dort verbringen, wo Sie sie wirklich brauchen. </div><br> <label class="collapse" for="six">Schlüssel und Türen</label> <input id=
"six" type="checkbox"><div class="index_list"> Angenommen, Sie haben ein Level mit ein paar Türen und einen Schlüssel für jede. Wie können Sie einen Schlüssel einfach für einen Schlüssel markieren? Normalerweise würden Sie dem Schlüssel und der Tür normalerweise nur eine ID zuweisen. Was wäre, wenn Sie einen Schlüssel zum Öffnen von 2 oder 3 Türen wünschen? Einfach. Sie benutzen eine MASKE. Der Tür würde ein einzelnes &quot;Bit&quot; zugewiesen werden, z. B. door_id = 1 (0001), ein anderes mit door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000) usw. Wenn wir wollten, dass der Schlüssel die Türen 1 und 3 öffnet, hätte der Schlüssel die MASKE 5 (die binär 101 ist). Wenn wir hier ein UND ausführen, und es kommt &quot;nicht Null&quot; heraus, dann wissen wir, ob der Schlüssel die Tür öffnen kann. Sie könnten auch Schlüssel haben, die nichts geöffnet haben, wenn Sie eine MASKE von 0 haben. Sehen Sie den Code unten für die eigentliche Überprüfung: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Schleifen von Zählern</label> <input id="seven" type="checkbox"><div class="index_list"> Nehmen wir an, wir wollen einen einfachen Animationszähler, der von 0 bis 15 zählt (da wir 16 Animationsbilder haben), jetzt können wir entweder ein Inkrement durchführen und dann eine IF, oder wir können unser Wissen über die Binärdarstellung verwenden und die WENN vollständig. IFs sind langsam, und wenn wir sie nicht brauchen, sollten wir sie entfernen. <br><br><p class="code">counter = (counter+1)&amp;15;<br><span class="notranslate"></span></p><br> Da 16 Frames eine Potenz von 2 sind und 0 im Zähler enthalten ist, können wir die POW2-Nummer um 1 reduzieren und als MASKE verwenden. Damit können wir unseren Zähler umschließen. Wenn sich der Zähler von 15 auf 16 bewegt, erhalten wir das Bitmuster 10000, und wenn wir dann AND mit 15 (Bitmuster 01111) setzen, erhalten wir den Wert 0. Dies bedeutet, dass der obige Code für das Umbrechen von Zählern unglaublich nützlich ist - solange Sie verwenden POW2-Frame-Nummern. </div><br> <label class="collapse" for="eight">Power Of 2 Check</label> <input id="eight" type="checkbox"><div class="index_list"> Was wäre, wenn Sie nachsehen wollten, ob etwas eine Potenz von 2 ist? Nun, hier ist ein netter kleiner Trick. Dies gibt WAHR zurück, wenn Argument0 eine Potenz von 2 ist. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Wenn wir also die Nummer 51 (110011) hätten, was macht das? Nun, wir bekommen diese... 110011 &amp; 110010, die uns offensichtlich mit FALSE belässt, da nach dem UND noch viele &quot;Bits&quot; übrig sind. Wenn wir 64 1000000 hatten, dann wird dies zu... 1000000 &amp; 0111111, die uns 0 lässt, also ist es WAHR. </div><br> <label class="collapse" for="nine">Indexausrichtung</label> <input id="nine" type="checkbox"><div class="index_list"> Hier ist ein kurzer Code zum Ausrichten an 2 Zahlen. (1,2,4,8,16 usw.). Dies kann für die Speicherzuweisung sehr nützlich sein oder sicherstellen, dass Sie Daten an die richtigen Grenzen schreiben. In diesem Beispiel muss Argument0 auf Byte Byte von Argument1 ausgerichtet sein, wobei Argument1 eine Potenz von 2 ist. Dieses kleine Skript rundet die nächste Begrenzung der gewünschten Zahl auf. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Rückseite: <a href="index.html">Index für zusätzliche Informationen</a> </div><div style="float:right"> Weiter: <a href="errors.html">Compiler-Fehler</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
