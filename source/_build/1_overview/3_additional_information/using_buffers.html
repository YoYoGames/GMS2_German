<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Puffer verwenden </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> bietet in GML eine Reihe von Funktionen für den Umgang mit <b>Puffern</b>. Die meisten Leute sollten mit diesem Begriff vertraut sein, da er im Umgang mit Computern und beim Programmieren ständig verwendet wird. Wenn Sie jedoch das Wort kennen, bedeutet das nicht, dass Sie wirklich wissen, was es bedeutet. Auf dieser Seite soll daher erläutert werden, was ein Puffer ist und wie er im Rahmen der Programmierung von <i><span class="notranslate">GameMaker Studio 2</span></i> kann. Die allgemeine Funktionsweise ist jedoch die gleiche, unabhängig von der Sprache oder der Technologie. Dies ist einer der Gründe, warum dies der Fall ist so wichtig. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">Was ist ein Puffer?</label> <input id="one"
type="checkbox"><div class="index_list"> Ein Puffer (in Programmierung) ist im Grunde ein Speicherplatz im Systemspeicher, in dem kleine <i>Datenpakete</i> für fast alles (z. B. Datenübertragung, Kollisionen, Farbdaten usw.) gespeichert werden. Da es im Systemspeicher abgelegt wird, ist der Zugriff sehr schnell, und in der Regel wird ein Puffer für eine sehr kurzfristige Speicherung verwendet, z. B. das Empfangen von Netzwerkinformationen vor der Verarbeitung oder das Speichern eines Kontrollpunkts in Ihrem Spiel (dies wird im erklärt Beispiel weiter unten auf der Seite). <img class="center" src=
"images/buffer_memory.png" alt="Pufferspeicher"> Puffer werden durch Zuweisung eines in <b>Byte</b> berechneten Speicherplatzes im Systemspeicher erstellt, der dann für Ihr Spiel reserviert ist, solange Ihr Spiel läuft oder bis Sie den Puffer mit der entsprechenden Funktion löschen. Dies bedeutet, dass der Puffer auch dann noch vorhanden ist, wenn das Spiel nicht im Fokus ist (z. B. wird das Spiel bei einem Anruf auf einem mobilen Gerät in den Hintergrund gestellt), wenn das Spiel in den Hintergrund gestellt wird Puffer geht verloren. <br><br><div class="note"> HINWEIS <b>: Beim</b> Neustart des Spiels wird der Puffer nicht gelöscht oder gelöscht! Dies verhindert jedoch den weiteren Zugriff auf den zuvor erstellten Puffer, da das ID- <b>Handle</b> verloren gegangen ist und ein Speicherleck verursacht wird, das Ihr Spiel letztendlich zum Absturz bringen kann. Denken Sie daran, beim Neustart eines Spiels zuerst den Puffer zu löschen. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Puffertypen</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> ermöglicht die Erstellung von vier verschiedenen Puffertypen. Der Grund dafür ist, dass Puffer ein hochoptimiertes temporäres Speichermedium sind. Daher sollten Sie einen Puffer erstellen, der für den Datentyp geeignet ist, den Sie speichern möchten. Andernfalls könnten Fehler auftreten oder <i>Engpässe auftreten</i> in Ihrem Code. Bevor wir dies näher erläutern, betrachten wir die vier verfügbaren Puffertypen (als <b>Konstanten</b> in GML definiert): <br><br><div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Ein Puffer mit fester Größe in Byte. Die Größe wird beim Erstellen des Puffers festgelegt und kann nicht mehr geändert werden. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Ein Puffer, der beim Hinzufügen von Daten dynamisch <i>wächst</i>. Sie erstellen es mit einer Anfangsgröße (dies sollte eine Annäherung an die Größe der zu speichernden Daten sein), und es wird dann erweitert, um weitere Daten zu akzeptieren, die diese Anfangsgröße überfluten. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Ein Puffer, in den die Daten <i>umgebrochen werden</i>. Wenn die hinzugefügten Daten die Grenze der Puffergröße erreichen, wird das Überschreiben wieder an den Anfang des Puffers gesetzt, und das weitere Schreiben wird ab diesem Punkt fortgesetzt. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> Dies ist ein spezieller &quot;abgespeckter&quot; Puffer, der extrem schnell lesen und schreiben kann. Es kann jedoch nur mit verwendet werden <tt>buffer_u8</tt> Datentypen und muss 1 Byte ausgerichtet sein. (Informationen zu <b>Datentypen</b> und <b>Byte-Ausrichtung</b> finden Sie weiter unten auf dieser Seite.) <br><br></td></tr></table></div><br><br> Dies sind die Puffertypen, die Ihnen bei der Verwendung von <i><span class="notranslate">GameMaker</span> Studio 2</i> zur Verfügung stehen. Welche Sie wählen, hängt stark von der Verwendung ab, für die Sie sie einsetzen möchten. Zum Beispiel würde ein <b>Wachstumspuffer</b> zum Speichern eines &quot;Schnappschusses&quot; von Daten verwendet, um ein Sicherungsspiel zu erstellen, da Sie nicht wissen, welche Datenmenge tatsächlich darin abgelegt wird, oder wenn Sie einen <b>schnellen</b> Puffer verwenden Sie wissen, dass die Werte, mit denen Sie arbeiten, alle zwischen 0 und 255 oder -128 und 127 liegen, zum Beispiel bei der Verarbeitung von RGB-Daten aus einem Bild. <img class="center" src="images/buffer_types.png" alt="Puffertypen"> Beim Erstellen eines Puffers sollten Sie immer versuchen, ihn in einer dem Typ angemessenen Größe zu erstellen. Die allgemeine Regel besagt, dass der Puffer für die maximale Größe der zu speichernden Daten erstellt werden sollte. Verwenden Sie einen <b>Wachstumspuffer</b>, um Überschreibfehler zu vermeiden. <br><br> Der eigentliche Code zum Erstellen eines Puffers würde ungefähr so ​​aussehen: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Dies würde einen festen Puffer von 16384 Bytes erzeugen und das <b>Byte auf</b> 2 <b>ausrichten</b>, wobei die Funktion einen eindeutigen <b>ID-</b> Wert zurückgibt, der in einer Variablen für die spätere Referenzierung dieses Puffers gespeichert wird. Nun haben wir das grundlegende Konzept eines Puffers erklärt, in dem Sie etwas über <b>Datentypen</b> und die zuvor erwähnte <b>Byte-Ausrichtung</b> erfahren sollten. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Pufferdatentypen</label> <input id="three" type="checkbox"><div class="index_list"> Wenn Sie Daten lesen und in einen Puffer schreiben, tun Sie dies in Datenblöcken, die durch ihren Datentyp &#39;&#39; &#39;definiert sind. Der Datentyp &#39;&#39; &#39;&#39; bestimmt die Anzahl der Bytes, die innerhalb des Puffers für den zu schreibenden Wert reserviert sind, und es ist wichtig, dass Sie dies richtig machen, da Sie sonst sehr seltsame Ergebnisse (oder sogar Fehler) für Ihren Code erhalten. <br><br> Puffer werden <i>sequentiell beschrieben</i> (und aus diesem gelesen), indem ein Datenstück nach dem anderen geschrieben wird, wobei jedes Datenelement vom Settyp ist. Dies bedeutet, dass Sie im Idealfall wissen sollten, welche Daten Sie jederzeit in den Puffer schreiben. Diese <b>Datentypen</b> werden in GML durch die folgenden <i>Konstanten definiert</i>: <div class="compat"><table><tr><th> Datentyp Konstante </th><th> Bytes </th><th> Beschreibung </th></tr><tr><td> buffer_u8 </td><td> 1 </td><td><br> Eine vorzeichenlose 8-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 bis 255. <br><br></td></tr><tr class="alt"><td> buffer_s8 </td><td> 1 </td><td><br> Eine vorzeichenbehaftete 8-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -128 bis 127 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> buffer_u16 </td><td> 2 </td><td><br> Eine vorzeichenlose 16-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 - 65.535. <br><br></td></tr><tr class="alt"><td> buffer_s16 </td><td> 2 </td><td><br> Eine vorzeichenbehaftete 16-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -32.768 bis 32.767 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> buffer_f16 </td><td> 2 </td><td><br> Eine 16-Bit-Gleitkommazahl. Dies kann ein positiver oder negativer Wert im Bereich von +/- 65504 sein. <b>(Derzeit nicht unterstützt!)</b> <br><br></td></tr><tr><td> buffer_u32 </td><td> 4 </td><td><br> Eine vorzeichenlose 32-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 bis 4.294.967.295. <br><br></td></tr><tr class="alt"><td> buffer_s32 </td><td> 4 </td><td><br> Eine vorzeichenbehaftete 32-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -2.147.483.648 bis 2.147.483.647 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> buffer_f32 </td><td> 4 </td><td><br> Eine 32-Bit-Gleitkommazahl. Dies kann ein positiver oder negativer Wert im Bereich von +/- 16777216 sein. <br><br></td></tr><tr class="alt"><td> buffer_u64 </td><td> 8 </td><td><br> Ein 64-Bit-Ganzzahl ohne Vorzeichen. <b>(Derzeit nicht von allen Pufferfunktionen unterstützt!)</b> <br><br></td></tr><tr><td> buffer_f64 </td><td> 8 </td><td><br> Eine 64-Bit-Gleitkommazahl. <br><br></td></tr><tr class="alt"><td> buffer_bool </td><td> 1 </td><td><br> Ein boolescher Wert. Kann nur 1 oder 0 sein ( <tt>true</tt> oder <tt>false</tt> ) <br><br></td></tr><tr><td> Pufferzeichenfolge </td><td> N / A </td><td><br> Dies ist eine UTF-8-Null-Zeichenfolge (0x00). Grundsätzlich wird ein <span class="notranslate">GameMaker</span> String in den Puffer <span class="notranslate">GameMaker</span> und am Ende eine 0 gesetzt. <br><br></td></tr></table></div><br><br> Angenommen, Sie haben einen Puffer erstellt und möchten Informationen in den Puffer schreiben, dann würden Sie etwa folgenden Code verwenden: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> Wenn Sie sich das Beispiel oben ansehen, können Sie sehen, dass Sie verschiedene Datentypen in einen Puffer schreiben können (Sie sind bei Verwendung des <b>schnellen</b> Puffertyps nur auf einen bestimmten Datentyp beschränkt), und diese Daten werden nacheinander in den Puffer eingefügt (obwohl dies der Fall ist.) Die tatsächliche Position im Puffer hängt von seiner <b>Byte-Ausrichtung ab</b> (siehe unten). Dies gilt auch für das Lesen von Informationen aus dem Puffer. Im obigen Beispiel würden Sie in derselben Reihenfolge aus dem Puffer lesen, in der Sie die Daten geschrieben haben, und zwar auf denselben Datentyp prüfen, z. B.: <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Wie Sie sehen, lesen Sie die Informationen in derselben Reihenfolge aus, in der Sie sie in den Puffer eingelesen haben. Weitere Informationen zum Hinzufügen und Entfernen von Daten aus dem Puffer finden Sie im Abschnitt <b>Beispiele</b> unten. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Pufferausrichtung</label> <input id="four"
type="checkbox"><div class="index_list"> Wenn Sie diese Seite gelesen haben, haben Sie Verweise auf die <b>Byte-Ausrichtung</b> eines Puffers gesehen. Dies bezieht sich im Wesentlichen auf die <i>Position</i>, an der neue Daten in einem bestimmten Puffer gespeichert werden. Wie funktioniert das? Für einen einzelnen Byte-ausgerichteten Puffer wird jedes Datenstück sequentiell in den Puffer geschrieben, wobei jedes neue Datenstück direkt nach dem vorherigen hinzugefügt wird. Ein 2-Byte-ausgerichteter Puffer schreibt jedoch jedes Datenelement in Intervallen von 2 Bytes, sodass der <i>nächste</i> Schreibvorgang selbst dann verschoben wird, wenn er aus 1 Byte Daten besteht. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Pufferbyte-Ausrichtung"> Wenn Ihre Byte-Ausrichtung beispielsweise auf 4 Byte eingestellt ist und Sie ein einzelnes Datenstück mit einer Größe von 1 Byte schreiben, dann führen Sie einen <i>Pufferspeicher aus</i> (ein <b>Tell</b> erhält die aktuelle Position zum Lesen / Schreiben des Puffers) Ich bekomme einen <i>Offset</i> von 1 (der Offset ist in diesem Fall die Anzahl der Bytes vom Start des Puffers bis zur aktuellen Lese- / Schreibposition). <br><br> Wenn Sie jedoch ein weiteres Datenstück schreiben, das ebenfalls 1 Byte groß ist, <i>dann</i> geben Sie einen Puffer an, und Sie erhalten einen Versatz von 5 Byte (obwohl Sie nur 2 Byte Daten geschrieben haben), da die Daten durch das Alignment <i>aufgefüllt</i> werden um es mit der 4-Byte-Pufferausrichtung auszurichten. <br><br> Im Grunde bedeutet dies, dass die Ausrichtung nur die Position beeinflusst, <i>in die Dinge geschrieben</i> werden. Wenn Sie also nach dem Schreiben eines Puffers sagen, wird die aktuelle Schreibposition zurückgegeben, die unmittelbar auf die zuvor geschriebenen Daten folgt. Wenn Sie jedoch ein weiteres Datenstück schreiben, wird der Puffer intern die Schreibposition entlang des nächsten Vielfachen der Ausrichtungsgröße verschieben, bevor das Datenelement tatsächlich geschrieben wird. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Puffer Beispiele</label> <input id="five"
type="checkbox"><div class="index_list"> Nachfolgend finden Sie einige Beispiele für die Verwendung von Puffern. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Einen Checkpoint machen</label> <input id="six" type="checkbox"><div class="index_list"> Ein einfaches Beispiel für die Verwendung eines Puffers in einem <i><span class="notranslate">GameMaker Studio 2</span></i> Spiel für jede Plattform ist die Funktion <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Diese Funktion erstellt einen &quot;Schnappschuss&quot; des aktuellen Spielstatus und speichert ihn in einem vordefinierten Puffer, aus dem gelesen werden kann, um das Spiel an diesem Punkt erneut zu laden. <br><br><div class="note"> <b>HINWEIS:</b> Diese Funktion ist sehr eingeschränkt und wurde für Anfänger entwickelt, um ein Checkpoint-System schnell zum Laufen zu bringen. Fortgeschrittene Benutzer können es jedoch vorziehen, ihr eigenes System mithilfe der <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">Dateifunktionen</a> zu codieren, da das Spiel nicht gespeichert wird alle dynamischen Ressourcen, die Sie zur Laufzeit erstellen können, wie Datenstrukturen, Oberflächen, hinzugefügte Hintergründe und Sprites usw. </div><br> Als Erstes müssen Sie ein neues Objekt erstellen, um das Speichern und Laden zu steuern, sodass Sie eines <b>erstellen</b> und ein <b>Ereignis erstellen erstellen können</b>. In diesem Fall können Sie den folgenden Code eingeben: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> In der ersten Zeile wird ein <b>Wachstumspuffer</b> (da wir die endgültige Größe der gespeicherten Daten nicht kennen) von 1024 Byte erstellt und auf 1 Byte ausgerichtet. Anschließend wird eine Variable erstellt, mit der geprüft wird, ob das Spiel gespeichert wurde oder nicht (dies wird zum Laden verwendet). <br><br> Als nächstes fügen wir ein <b>Keypress-Event hinzu</b> (zum Beispiel), in dem wir den aktuellen Spielstatus im erstellten Puffer speichern: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Das obige setzt zuerst die Steuervariable auf true (damit diese gespeichert wird, wenn wir das Spiel im Puffer speichern) und <i>sucht</i> dann den Anfang des Puffers, bevor der aktuelle Speicherzustand in den Puffer geschrieben wird. Warum benutzen wir? <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Nun, wie oben in der <b>Pufferdatentypen</b> Abschnitt erwähnt, können Sie auf einen Puffer von der letzten Position lesen und schreiben, dass Daten, die ihm zugefügt. Dies bedeutet, dass, wenn Sie nicht den Puffer stellen Sie dann zu Beginn <i>sagen</i>, zurück, wenn Sie sparen Sie die Daten in die Puffer an den aktuellen Puffern / Schreibposition gelesen werden hinzugefügt, so verwenden wir die Funktion <tt>buffer_seek</tt> um den <i>Tell</i> zum Pufferanfang zu bewegen. <br><br> Wir haben jetzt den aktuellen Spielstand in einem Puffer gespeichert. Der nächste Schritt wäre zu codieren, wie man es lädt, wahrscheinlich in einem anderen <b>Keypress-Event</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Das Spiel wird dann am Ende des Ereignisses geladen, in dem Sie den obigen Code eingeben. <br><br><div class="note"> <b>HINWEIS:</b> Dies ist nur für den Einsatz in demselben Raum und nicht für die Generierung vollständig gespeicherter Spiele für das Schließen oder Neustarten des Spiels bestimmt! </div><br> Das letzte Objekt, das dem Controller-Objekt hinzugefügt werden soll, ist ein Bereinigungscode. Puffer werden im Speicher abgelegt. Wenn Sie also nicht bereinigen, wenn Sie damit fertig sind, können Sie Speicherlecks bekommen, die zu Verzögerungen führen und Ihr Spiel zum Absturz bringen. Sie würden also wahrscheinlich ein <b>Raumende-Ereignis</b> (aus der Kategorie <b>Andere</b> Ereignisse) hinzufügen mit: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Dieses Objekt kann nun in einem Raum platziert werden und bei einem Tastendruck speichern und den Raumzustand aus einem Puffer laden. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Netzwerkpuffer</label> <input id="seven" type="checkbox"><div class="index_list"> Wenn Sie mit den Netzwerkfunktionen von <i><span class="notranslate">GameMaker Studio</span> 2 arbeiten</i>, müssen Sie zum Erstellen des <i>Datenpakets</i>, das über die Netzwerkverbindung gesendet wird, Puffer verwenden. In diesem Beispiel soll gezeigt werden, wie dies ausgeführt wird. Aufgrund des Umfangs der Netzwerkmöglichkeiten soll jedoch nur gezeigt werden, wie die Puffer selbst verwendet werden und nicht das vollständige Netzwerksystem. <br><br> Als erstes zeigen wir die Erstellung und Verwendung eines Puffers für die Client-Seite der Netzwerkverbindung. Dieser Puffer wird verwendet, um kleine Datenpakete zu erstellen, die dann an den Server gesendet werden können. In der <b>Ereigniserstellung</b> einer Instanz würden wir einen Puffer wie folgt zuweisen: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Wir machen den Puffer klein (256 Byte), da er nicht zum Speichern großer Datenmengen vorgesehen ist. Wir machen ihn zum <i>Wachstumspuffer,</i> um sicherzustellen, dass keine Fehler auftreten, wenn zu jedem Zeitpunkt mehr zu sendende Daten hinzugefügt werden müssen und die Ausrichtung auf festgelegt ist eine für die Bequemlichkeit. <br><br> Angenommen, wir möchten, dass unser Kunde Daten an den Server sendet. Dafür brauchen wir einen Puffer „Paket“, und in diesem Beispiel erstellen wir werden ein <b>Tastendruckereignis</b> senden, wie wenn der Spieler <b>links</b> - <b>Taste</b> drückt, um das Spiel zu bewegen. Dazu schreiben wir zuerst die erforderlichen Daten in den Puffer und senden sie dann ab: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Vor dem Schreiben in den Puffer wir die „tell“ an den Anfang des Puffers gesetzt haben, wie Vernetzung <i>immer</i> die Daten von <b>Anfang</b> an eines Puffers erfolgt. Dann schreiben wir den <i>Prüfwert</i> (dieser wird vom Server verwendet, um die Art des Ereignisses zu bestimmen), dann den verwendeten Schlüssel und dann den Status des Schlüssels (in diesem Fall) <tt>true</tt> für gedrückt). Dieser Puffer wird dann von der Netzwerkfunktion als Datenpaket gesendet. Beachten Sie, dass wir <i>nicht</i> den gesamten Puffer senden! Wir senden nur die geschriebenen Daten mit der <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> Funktion, um die aktuelle Lese- / Schreibposition des Puffers zurückzugeben (denken Sie daran, dass das Schreiben in den Puffer das &quot;tell&quot; an das Ende des Geschriebenen schiebt). <br><br> Was ist mit dem Empfang der Daten auf dem Server? Das empfangene Datenpaket, das in den Puffer auf dem Server geschrieben und dann zum Aktualisieren des Spiels verwendet werden muss. Dafür würden wir das <a href=
"../../2_interface/1_editors/events/async_events.html">Netzwerk-asynchrone Ereignis</a> im Netzwerkcontrollerobjekt des Servers verwenden, wie dieser vereinfachte Code unten zeigt: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Das asynchrone Ereignis enthält ein spezielles temporäres Ereignis <tt>ds_map</tt> (wird am Ende des Ereignisses automatisch entfernt). Diese enthält je nach Art der vom Netzwerk eingehenden Daten unterschiedliche Informationen. In diesem Fall gehen wir davon aus, dass die Karte geprüft wurde und ein Pufferdatenpaket ist, das von einem Client gesendet wurde. Wir prüfen nun das erste Datenelement, das sich im Puffer befindet, um zu sehen, welche Art von Ereignis gesendet wurde. In diesem Fall stellt der Wert &quot;1&quot; ein <i>Schlüsselereignis dar.</i> Beim Codieren dieser Elemente sollten Sie jedoch <b>Konstanten</b> definieren, für die diese Werte gespeichert werden sollen Dinge vereinfachen - und dann die gedrückte Taste und ihren Zustand speichern ( <tt>true</tt> = gedrückt, <tt>false</tt> = freigegeben). Diese Informationen werden dann verwendet, um alle Clients mit dem neuen Status des sendenden Client-Players zu aktualisieren. <br><br><div class="note"> <b>HINWEIS:</b> Der aus der ds_map erstellte Puffer wird am Ende des asynchronen Netzwerkereignisses automatisch entfernt, sodass keine Verwendung erforderlich ist <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> Hier. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Rückseite: <a href="index.html">Index für zusätzliche Informationen</a> </div><div style="float:right"> Weiter: <a href="texture_pages.html">Textur-Seiten</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
