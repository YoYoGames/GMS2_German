<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Puffer verwenden </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> hat eine Reihe von Funktionen in GML, um mit <b>Puffern</b> umzugehen. Die meisten Menschen sollten mit diesem Begriff vertraut sein, da er ständig verwendet wird, wenn es um Computer und Programmierung geht, aber das Wissen über das Wort bedeutet nicht, dass Sie wirklich wissen, was es bedeutet. Auf dieser Seite soll erklärt werden, was ein Puffer ist und wie man ihn im Kontext der <i><span class="notranslate">GameMaker Studio 2</span></i> Programmierung verwendet, obwohl die allgemeine Funktionsweise derselben unabhängig von der Sprache oder der Technologie gleich ist, was einer der Gründe dafür ist so wichtig. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">Was ist ein Puffer?</label> <input id="one"
type="checkbox"><div class="index_list"> Ein Puffer (in der Programmierung) ist im Grunde ein Raum innerhalb des Systemspeichers, der verwendet wird, um kleine <i>Datenpakete</i> für fast alles zu speichern (zum Beispiel Datentransfer, Kollisionen, Farbdaten usw.). Da es im Systemspeicher gehalten wird, ist es sehr schnell zugänglich, und ein Puffer würde im Allgemeinen für sehr kurzfristige Speicherung verwendet werden, wie zum Empfangen von Netzwerkinformationen vor der Verarbeitung oder zum Speichern eines Prüfpunkts in Ihrem Spiel (dies wird in der Beispiel weiter unten auf der Seite). <img class="center" src=
"images/buffer_memory.png" alt="Pufferspeicher"> Puffer werden erstellt, indem ein Speicherplatz im Systemspeicher reserviert wird, der in <b>Bytes</b> berechnet wird. Dieser Speicherplatz ist dann für Ihr Spiel reserviert, solange Ihr Spiel läuft oder bis Sie den Puffer mit der entsprechenden Funktion löschen. Dies bedeutet, dass auch wenn Ihr Spiel nicht im Fokus ist (zum Beispiel auf einem mobilen Gerät, wenn Sie einen Anruf annehmen, das Spiel in den Hintergrund tritt), der Puffer noch existiert, wenn das Spiel jedoch geschlossen oder neu gestartet wird Puffer wird verloren gehen. <br><br><div class="note"> HINWEIS <b>:</b> Durch das Neustarten des Spiels wird der Puffer nicht gelöscht oder gelöscht! Aber es wird jeden weiteren Zugriff auf den zuvor erstellten Puffer verhindern, da das ID- <b>Handle</b> verloren gegangen ist, was zu einem Speicherleck führen wird, der schließlich dein Spiel zum Absturz bringen wird. Wenn Sie ein Spiel neu starten, denken Sie daran, den Puffer zuerst zu löschen. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Pufferarten</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> können vier verschiedene Puffertypen erstellt werden. Der Grund dafür ist, dass Puffer als hoch optimiertes temporäres Speichermedium konzipiert sind. Daher sollten Sie einen Puffer erstellen, der dem Datentyp entspricht, den Sie speichern möchten. Andernfalls könnten Sie Fehler erhalten oder einen <i>Engpass verursachen</i> in deinem Code. Bevor wir dies weiter erklären, betrachten wir die vier verfügbaren Puffertypen (definiert als <b>Konstanten</b> in GML): <br><br><div class="compat"><table><tr><th> Konstante </th><th> Beschreibung </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Ein Puffer mit einer festen Größe in Bytes. Die Größe wird beim Erstellen des Puffers festgelegt und kann nicht mehr geändert werden. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Ein Puffer, der dynamisch <i>wächst</i>, wenn Daten hinzugefügt werden. Sie erstellen es mit einer Anfangsgröße (die eine Annäherung an die Größe der zu speichernden Daten sein sollte), und dann wird es erweitert, um weitere Daten zu akzeptieren, die diese Anfangsgröße überschreiten. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Ein Puffer, in den die Daten <i>eingefügt werden</i>. Wenn die hinzugefügten Daten das Limit der Puffergröße erreichen, wird das Überschreiben an den Anfang des Puffers zurückgesetzt und das weitere Schreiben wird von diesem Punkt aus fortgesetzt. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> Dies ist ein spezieller &quot;abgespeckter&quot; Puffer, der extrem schnell zu lesen / zu schreiben ist. Es kann jedoch nur mit verwendet werden <tt>buffer_u8</tt> Datentypen und muss 1 Byte ausgerichtet sein. (Informationen zu <b>Datentypen</b> und zur <b>Byteausrichtung</b> finden Sie weiter unten auf dieser Seite). <br><br></td></tr></table></div><br><br> Dies sind die verfügbaren Puffertypen, wenn Sie mit <i><span class="notranslate">GameMaker</span> Studio 2 arbeiten.</i> Welche <i><span class="notranslate">GameMaker</span></i> Sie auswählen, hängt stark von der Verwendung ab, die Sie verwenden möchten. Zum Beispiel würde ein <b>Wachstumspuffer</b> verwendet werden, um einen &quot;Schnappschuss&quot; von Daten zu speichern, um ein Speicherspiel zu erstellen, da Sie nicht die tatsächliche Menge an Daten kennen, die darin platziert wird, oder ein <b>schneller</b> Puffer würde verwendet werden, wenn Sie wissen Sie, dass die Werte, mit denen Sie arbeiten, alle zwischen 0 und 255 oder -128 und 127 liegen, wenn Sie beispielsweise RGB-Daten von einem Bild verarbeiten. <img class="center" src="images/buffer_types.png" alt="Pufferarten"> Wenn Sie einen Puffer erstellen, sollten Sie immer versuchen, ihn in einer Größe zu erstellen, die für den Typ geeignet ist. Die allgemeine Regel lautet, dass er erstellt werden sollte, um die maximale Größe der zu speichernden Daten zu berücksichtigen, und im Zweifelsfall Verwenden Sie einen <b>Wachstumspuffer</b>, um Überschreibfehler zu vermeiden. <br><br> Der tatsächliche Code zum Erstellen eines Puffers würde etwa so aussehen: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Dies würde einen festen Puffer von 16384 Bytes und ein <b>auf</b> 2 <b>ausgerichtetes Byte</b> erzeugen, wobei die Funktion einen eindeutigen <b>ID-</b> Wert zurückgibt, der in einer Variablen gespeichert ist, um später auf diesen Puffer zu referenzieren. Jetzt haben wir das Grundkonzept eines Puffers erläutert, dass Sie sich über <b>Datentypen</b> und die zuvor erwähnte <b>Byteausrichtung informieren sollten</b>. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Pufferdatentypen</label> <input id="three" type="checkbox"><div class="index_list"> Wenn Sie Daten in einen Puffer schreiben und schreiben, tun Sie dies in &quot;Chunks&quot; von Daten, die durch ihren Datentyp definiert sind. Der &#39;&#39; &#39;Datentyp legt die Anzahl der Bytes fest, die innerhalb des Puffers für den geschriebenen Wert zugewiesen werden, und es ist wichtig, dass Sie dies richtig ermitteln, da Sie andernfalls sehr seltsame Ergebnisse (oder sogar Fehler) für Ihren Code erhalten. <br><br> Puffer werden <i>sequentiell</i> geschrieben (und gelesen), indem ein Datenstück nach dem anderen geschrieben wird, wobei jedes Datenstück vom festgelegten Typ ist. Das bedeutet, dass Sie im Idealfall wissen sollten, welche Daten Sie zu jeder Zeit in den Puffer schreiben. Diese <b>Datentypen</b> sind in GML durch die folgenden <i>Konstanten definiert</i>: <div class="compat"><table><tr><th> Datentyp Konstante </th><th> Bytes </th><th> Beschreibung </th></tr><tr><td> Puffer_u8 </td><td> 1 </td><td><br> Eine vorzeichenlose 8-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 bis 255. <br><br></td></tr><tr class="alt"><td> Puffer_s8 </td><td> 1 </td><td><br> Eine vorzeichenbehaftete 8-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -128 bis 127 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> Puffer_u16 </td><td> 2 </td><td><br> Eine vorzeichenlose 16-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 - 65.535. <br><br></td></tr><tr class="alt"><td> Puffer_s16 </td><td> 2 </td><td><br> Eine vorzeichenbehaftete 16-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -32.768 bis 32.767 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> Puffer_u32 </td><td> 4 </td><td><br> Eine vorzeichenlose 32-Bit-Ganzzahl. Dies ist ein positiver Wert von 0 bis 4.294.967.295. <br><br></td></tr><tr class="alt"><td> Puffer_s32 </td><td> 4 </td><td><br> Eine vorzeichenbehaftete 32-Bit-Ganzzahl. Dies kann ein positiver oder negativer Wert von -2.147.483.648 bis 2.147.483.647 sein (0 wird als positiv eingestuft). <br><br></td></tr><tr><td> Puffer_f16 </td><td> 2 </td><td><br> Eine 16-Bit-Gleitkommazahl. Dies kann ein positiver oder negativer Wert im Bereich von +/- 65504 sein. <b>(</b> Wird <b>derzeit nicht unterstützt!)</b> <br><br></td></tr><tr class="alt"><td> Puffer_f32 </td><td> 4 </td><td><br> Eine 32-Bit Gleitkommazahl. Dies kann ein positiver oder negativer Wert im Bereich von +/- 16777216 sein. <br><br></td></tr><tr><td> Puffer_f64 </td><td> 8 </td><td><br> Eine 64-Bit Gleitkommazahl. Dies kann ein positiver oder negativer Wert von - (2 <sup>52</sup> ) bis 2 <sup>52</sup> - 1 sein. <br><br></td></tr><tr class="alt"><td> Puffer_Bool </td><td> 1 </td><td><br> Ein boolescher Wert. Kann nur 1 oder 0 sein ( <tt>true</tt> oder <tt>false</tt> ) <br><br></td></tr><tr><td> Pufferzeichenfolge </td><td> N / A </td><td><br> Dies ist eine UTF-8 null terminierte (0x00) Zeichenfolge. Grundsätzlich wird ein <span class="notranslate">GameMaker</span> String in den Puffer geworfen und am Ende eine 0 gesetzt. <br><br></td></tr></table></div><br><br> Wenn Sie beispielsweise einen Puffer erstellt haben und Informationen darauf schreiben möchten, verwenden Sie etwa den folgenden Code: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> Wenn Sie das obige Beispiel betrachten, können Sie sehen, dass Sie verschiedene Datentypen in einen Puffer schreiben können (Sie sind nur auf einen bestimmten Datentyp beschränkt, wenn Sie den <b>schnellen</b> Puffertyp verwenden), und diese Daten werden fortlaufend in den Puffer eingefügt Die tatsächliche Position in dem Puffer hängt von seiner <b>Byteausrichtung ab</b>, die nachstehend erläutert wird. Dies gilt auch für das Lesen von Informationen aus dem Puffer, und im obigen Beispiel würden Sie aus dem Puffer in der Reihenfolge lesen, in der Sie die Daten geschrieben haben, indem Sie nach dem gleichen Datentyp suchen, z. <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Wie Sie sehen können, lesen Sie Informationen in der gleichen Reihenfolge aus, in der Sie sie in den Puffer eingelesen haben. Weitere Informationen zum Hinzufügen und Entfernen von Daten aus dem Puffer finden Sie im folgenden Abschnitt &quot; <b>Beispiele</b> &quot;. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Pufferausrichtung</label> <input id="four"
type="checkbox"><div class="index_list"> Wenn Sie diese Seite durchgelesen haben, haben Sie Hinweise auf die <b>Byteausrichtung</b> eines Puffers gesehen. Dies bezieht sich im Wesentlichen auf die <i>Position,</i> dass neue Daten in einem bestimmten Puffer gespeichert werden. Wie funktioniert das? Nun, für einen einzelnen Byte-ausgerichteten Puffer wird jedes Datenstück sequentiell in den Puffer geschrieben, wobei jedes neue Datenstück direkt nach dem vorherigen hinzugefügt wird. Ein 2 Byte ausgerichteter Puffer schreibt jedoch jedes Datenstück in Intervalle von 2 Bytes, so dass, selbst wenn Ihr anfängliches Schreiben 1 Byte Daten ist, der <i>nächste</i> Schreibvorgang verschoben wird, um auf zwei Bytes auszurichten. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Puffer-Byte-Ausrichtung"> Also, wenn Ihre Byteausrichtung auf beispielsweise 4 Bytes gesetzt ist und Sie ein einzelnes Stück Daten schreiben, das 1 Byte groß ist, dann tun Sie einen <i>Puffer Tell</i> (ein <b>Tell</b> erhält die aktuelle Position zum Lesen / Schreiben für den Puffer), Sie Ich bekomme einen <i>Offset</i> von 1 (der Offset ist in diesem Fall die Anzahl der Bytes vom Anfang des Puffers bis zur aktuellen Lese- / Schreibposition). <br><br> Wenn Sie ein anderes Stück von Daten, auch 1 Byte in Größe jedoch schreiben, <i>dann</i> erzählen Sie einen Puffer, werden Sie einen Versatz von 5 Bytes bekommen (auch wenn Sie nur 2 Bytes Daten geschrieben haben), da die Ausrichtung der Daten <i>aufgefüllt</i> wurde um es mit der 4-Byte-Pufferausrichtung auszurichten. <br><br> Im Grunde bedeutet dies, dass die Ausrichtung nur Auswirkungen darauf hat, <i>wo Dinge geschrieben</i> werden. Wenn Sie also nach dem Schreiben eines Buffers eine Tell-Anweisung ausführen, wird die aktuelle Schreibposition zurückgegeben, die unmittelbar auf die Daten folgt, die Sie zuvor geschrieben haben. Beachten Sie jedoch, dass der Puffer die Schreibposition intern auf das nächste Vielfache der Ausrichtungsgröße vor dem eigentlichen Schreiben des Datenelements verschiebt, wenn Sie dann ein weiteres Datenelement schreiben. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Puffer Beispiele</label> <input id="five"
type="checkbox"><div class="index_list"> Im Folgenden finden Sie einige Beispiele für häufige Verwendungen von Puffern. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Einen Checkpoint machen</label> <input id="six" type="checkbox"><div class="index_list"> Ein einfaches Beispiel dafür, wie ein Puffer in jedem <i><span class="notranslate">GameMaker Studio 2</span></i> Spiel für jede Plattform verwendet werden kann, ist die Funktion <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Diese Funktion erstellt einen &quot;Schnappschuss&quot; des aktuellen Spielstandes und speichert ihn in einem vordefinierten Puffer, der dann ausgelesen werden kann, um das Spiel an diesem Punkt wieder zu laden. <br><br><div class="note"> <b>HINWEIS:</b> Diese Funktion ist sehr begrenzt und wurde entwickelt, damit Einsteiger ein Checkpoint-System schnell in Betrieb nehmen können. Erfahrene Benutzer ziehen es jedoch vor, ihr eigenes System mit den <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">Dateifunktionen zu programmieren</a>, da das Spiel nicht gespeichert wird Alle dynamischen Ressourcen, die Sie zur Laufzeit erstellen können, wie Datenstrukturen, Oberflächen, hinzugefügte Hintergründe und Sprites usw. </div><br> Das erste, was wir tun müssen, ist ein neues Objekt zu erstellen, um das Speichern und Laden zu steuern, so dass Sie eines <b>erstellen</b> und ihm ein <b>Create Event geben</b>. In diesem Fall könnten Sie den folgenden Code eingeben: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> Die erste Zeile erstellt einen <b>Grow-</b> Puffer (da wir die endgültige Größe der gespeicherten Daten nicht kennen) von 1024 Bytes und ist auf 1 Byte ausgerichtet. Es wird dann eine Variable erstellt, um zu überprüfen, ob das Spiel gespeichert wurde oder nicht (dies wird zum Laden verwendet). <br><br> Als nächstes würden wir ein <b>Keypress Event</b> (zum Beispiel) hinzufügen, in dem wir den aktuellen Spielstatus in den erstellten Puffer speichern: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Das obige setzt zuerst die Steuervariable auf wahr (so dass dies gespeichert wird, wenn wir das Spiel in den Puffer speichern) und dann auf den Anfang des Puffers vor dem Schreiben des aktuellen Sicherungszustands in den Puffer <i>suchen</i>. Warum benutzen wir? <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Nun, wie im Abschnitt <b>Pufferdatentypen</b> oben erwähnt, lesen und schreiben Sie in einen Puffer von der letzten Position aus, der Daten hinzugefügt wurden. Dies bedeutet, dass, wenn Sie nicht den Puffer stellen Sie dann zu Beginn <i>sagen</i>, zurück, wenn Sie sparen Sie die Daten in die Puffer an den aktuellen Puffern / Schreibposition gelesen werden hinzugefügt, so verwenden wir die Funktion <tt>buffer_seek</tt> um den <i>Tell</i> zum Pufferstart zu bewegen. <br><br> Wir haben jetzt den aktuellen Spielstatus in einem Puffer gespeichert. Der nächste Schritt wäre, zu <b>programmieren,</b> wie es geladen wird, wahrscheinlich in einem anderen <b>Keypress Event</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Das Spiel wird dann am Ende des Ereignisses geladen, in dem Sie den obigen Code platzieren. <br><br><div class="note"> <b>HINWEIS:</b> Dies ist nur für den Gebrauch im selben Raum und nicht für das Erstellen kompletter gespeicherter Spiele, nachdem dein Spiel geschlossen oder neu gestartet wurde! </div><br> Die letzte Sache, die dem Controller-Objekt hinzugefügt werden muss, ist ein &quot;Bereinigungs&quot; -Code. Puffer werden im Speicher gespeichert, und wenn Sie nicht sauber machen, wenn Sie damit fertig sind, können Sie Speicherlecks bekommen, die Ihr Spiel irgendwann verzögern und zum Absturz bringen. Daher würden Sie wahrscheinlich ein <b>Raumende-Ereignis</b> (aus der <b>anderen</b> Ereigniskategorie) hinzufügen mit: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Dieses Objekt kann nun in einen Raum platziert werden und auf einen Tastendruck speichern und den Raumzustand aus einem Puffer laden. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Netzwerkpuffer</label> <input id="seven" type="checkbox"><div class="index_list"> Wenn Sie mit den Netzwerkfunktionen von <i><span class="notranslate">GameMaker Studio</span> 2 arbeiten</i>, müssen Sie Puffer verwenden, um das <i>Datenpaket</i> zu erstellen, das über die Netzwerkverbindung gesendet wird. Dieses Beispiel soll zeigen, wie dies gemacht wird, aber aufgrund des Umfangs der Netzwerkmöglichkeiten ist es nur dafür entworfen, zu zeigen, wie die Puffer selbst und nicht das vollständige Netzwerksystem zu verwenden ist. <br><br> Das erste, was wir zeigen werden, ist die Erstellung und Verwendung eines Puffers für die Client-Seite der Netzwerkverbindung. Dieser Puffer wird verwendet, um kleine Datenpakete zu erstellen, die dann an den Server gesendet werden können, also würden wir im <b>Create Event</b> einer Instanz einen Puffer wie diesen zuweisen: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Wir machen den Puffer klein (256 Bytes), da er nicht für große Datenmengen gedacht ist, wir machen ihn zu einem <i>Wachstumspuffer,</i> um sicherzustellen, dass keine Fehler mehr Daten hinzufügen müssen, die zu jeder Zeit gesendet werden sollen, und die Ausrichtung ist auf eine für die Bequemlichkeit. <br><br> Nehmen wir an, wir möchten, dass unser Client Daten an den Server sendet. Dafür brauchen wir einen Puffer „Paket“, und in diesem Beispiel erstellen wir werden ein <b>Tastendruckereignis</b> senden, wie wenn der Spieler <b>links</b> - <b>Taste</b> drückt, um das Spiel zu bewegen. Dazu schreiben wir zuerst die notwendigen Daten in den Puffer und senden sie dann ab: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Vor dem Schreiben in den Puffer haben wir das &quot;Tell&quot; auf den Anfang des Puffers gesetzt, da das Netzwerk <i>immer</i> die Daten vom <b>Anfang</b> eines Puffers übernimmt. Wir schreiben dann den <i>Prüfwert</i> (dies wird vom Server verwendet, um den Typ des zu verarbeitenden Ereignisses zu bestimmen), dann den verwendeten Schlüssel und dann den Status des Schlüssels (in diesem Fall) <tt>true</tt> für gedrückt). Dieser Puffer wird dann als Datenpaket von der Netzwerkfunktion gesendet. Beachten Sie, dass wir <i>nicht</i> den gesamten Puffer senden! Wir senden nur die geschriebenen Daten, mit der <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> Funktion zum Zurückgeben der aktuellen Lese- / Schreibposition des Puffers (denken Sie daran, dass das Schreiben in den Puffer das &quot;Tell&quot; an das Ende dessen, was geschrieben wurde, bewegt). <br><br> Was ist mit dem Empfang der Daten auf dem Server? Das empfangene Datenpaket, das in den Puffer auf dem Server geschrieben und dann zur Aktualisierung des Spiels verwendet werden muss. Dazu würden wir das <a href=
"../../2_interface/1_editors/events/async_events.html">Netzwerk asynchrone Ereignis</a> im Netzwerk-Controller-Objekt des Servers verwenden, da dieser vereinfachte Code unten zeigt: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Das asynchrone Ereignis enthält ein spezielles temporäres Ereignis <tt>ds_map</tt> (Es wird automatisch am Ende des Ereignisses entfernt), das je nach Art der eingehenden Daten aus dem Netzwerk unterschiedliche Informationen enthält. In diesem Fall nehmen wir an, dass die Karte überprüft wurde und dass sie ein Pufferdatenpaket ist, das von einem Client gesendet wird. Wir überprüfen jetzt den ersten Teil der Daten im Puffer, um zu sehen, welche Art von Ereignis gesendet wurde - in diesem Fall stellt der Wert &quot;1&quot; ein <i>Schlüsselereignis dar.</i> Wenn Sie diese Dinge kodieren, sollten Sie jedoch <b>Konstanten</b> definieren, die diese Werte enthalten Dinge vereinfachen - und dann den zu drückenden Schlüssel und seinen Zustand speichern ( <tt>true</tt> = gedrückt, <tt>false</tt> = freigegeben). Diese Information würde dann verwendet werden, um alle Clients mit dem neuen Status des sendenden Client-Players zu aktualisieren. <br><br><div class="note"> <b>Hinweis:</b> Der Puffer, der von der ds_map erstellt wird, wird am Ende des asynchronen Netzwerkereignisses automatisch entfernt, so dass keine Verwendung erforderlich ist <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> Hier. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Zurück: <a href="index.html">Zusätzlicher Informationsindex</a> </div><div style="float:right"> Weiter: <a href="texture_pages.html">Textur Seiten</a> </div></div></div><h5> © Urheberrecht <span class="notranslate">YoYo Games Ltd.</span> 2017 Alle Rechte vorbehalten </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
